<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>GoRogue: GoRogue Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">GoRogue
   </div>
   <div id="projectbrief">C# roguelike/2D game utility library.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a>  </div>
  <div class="headertitle">
<div class="title">GoRogue Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_go_rogue_1_1_adjacency_rule.html">AdjacencyRule</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing a method for determining which coordinates are adjacent to a given coordinate, and in which directions those neighbors are. Cannot be instantiated &ndash; premade static instances are provided.  <a href="class_go_rogue_1_1_adjacency_rule.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_go_rogue_1_1_bounded_rectangle.html">BoundedRectangle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that contains a rectangle Area that is automatically "locked" to being inside the BoundingBox. A typical use might be keeping track of a camera view area.  <a href="class_go_rogue_1_1_bounded_rectangle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_go_rogue_1_1_coord.html">Coord</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">2d coordinate class. You cannot create instances of this class using a constructor &ndash; instead, use the Get function to create instances. Also provides numerous static functions to deal with grid/Coord-related math, operations, etc.  <a href="class_go_rogue_1_1_coord.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_go_rogue_1_1_direction.html">Direction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_go_rogue_1_1_utility.html" title="Static class full of miscellaneous helper methods. ">Utility</a> class to handle Directions on a grid map. The built-in variables hold the dx and dy for that direction, at unit scale.  <a href="class_go_rogue_1_1_direction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_go_rogue_1_1_disjoint_set.html">DisjointSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic representation of a Disjoint set data structure. Assumes it is holding integers between 0 and size - 1.  <a href="class_go_rogue_1_1_disjoint_set.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_go_rogue_1_1_distance.html">Distance</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing a method of calculating distance. You cannot create instances of this class using a constructor &ndash; instead this class contains static instances representing the applicable types of distance calculations.  <a href="class_go_rogue_1_1_distance.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_go_rogue_1_1_effect.html">Effect</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class designed to represent any sort of in-game effect. This could be anything from a simple physical damage effect to a heal effect, including area of effects, damage over time effects, or even potentially a special effect that simply boosts a stat.  <a href="class_go_rogue_1_1_effect.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_go_rogue_1_1_effect_args.html">EffectArgs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default argument for any effect. Any class that is used as the template argument for an effect must either be this or a class that inherits from this.  <a href="class_go_rogue_1_1_effect_args.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_go_rogue_1_1_effect_trigger.html">EffectTrigger</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an "event" that can trigger one or more Effects of the appropriate type. Typically instnaces of this class can simply be created, however a subclass may be required for custom add/remove actions and ordering.  <a href="class_go_rogue_1_1_effect_trigger.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_go_rogue_1_1_f_o_v.html">FOV</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class responsible for caculating basic <a class="el" href="class_go_rogue_1_1_f_o_v.html" title="Class responsible for caculating basic FOV (see SenseMap for more advanced lighting). Effectively a simplified, slightly faster interface compared to SenseMap, that supports only a single source and only shadowcasting. This is more conducive to the typical use case for FOV. It can calculate the FOV with a finite or infinite max radius, and can use a variety of radius types, as specified in Radius class (all the same ones that SenseMap supports). It also supports both 360 degree FOV and a &quot;field of view&quot; (cone) FOV. One may access this class like a 2D array of doubles (FOV values), wherein the values will range from 0.0 to 1.0, where 1.0 means the corresponding map grid coordinate is at maximum visibility, and 0.0 means the cooresponding coordinate is outside of FOV entirely (not visible). ">FOV</a> (see SenseMap for more advanced lighting). Effectively a simplified, slightly faster interface compared to SenseMap, that supports only a single source and only shadowcasting. This is more conducive to the typical use case for <a class="el" href="class_go_rogue_1_1_f_o_v.html" title="Class responsible for caculating basic FOV (see SenseMap for more advanced lighting). Effectively a simplified, slightly faster interface compared to SenseMap, that supports only a single source and only shadowcasting. This is more conducive to the typical use case for FOV. It can calculate the FOV with a finite or infinite max radius, and can use a variety of radius types, as specified in Radius class (all the same ones that SenseMap supports). It also supports both 360 degree FOV and a &quot;field of view&quot; (cone) FOV. One may access this class like a 2D array of doubles (FOV values), wherein the values will range from 0.0 to 1.0, where 1.0 means the corresponding map grid coordinate is at maximum visibility, and 0.0 means the cooresponding coordinate is outside of FOV entirely (not visible). ">FOV</a>. It can calculate the <a class="el" href="class_go_rogue_1_1_f_o_v.html" title="Class responsible for caculating basic FOV (see SenseMap for more advanced lighting). Effectively a simplified, slightly faster interface compared to SenseMap, that supports only a single source and only shadowcasting. This is more conducive to the typical use case for FOV. It can calculate the FOV with a finite or infinite max radius, and can use a variety of radius types, as specified in Radius class (all the same ones that SenseMap supports). It also supports both 360 degree FOV and a &quot;field of view&quot; (cone) FOV. One may access this class like a 2D array of doubles (FOV values), wherein the values will range from 0.0 to 1.0, where 1.0 means the corresponding map grid coordinate is at maximum visibility, and 0.0 means the cooresponding coordinate is outside of FOV entirely (not visible). ">FOV</a> with a finite or infinite max radius, and can use a variety of radius types, as specified in <a class="el" href="class_go_rogue_1_1_radius.html" title="Class representing different radius types. Similar in architecture to Coord in architecture – it can...">Radius</a> class (all the same ones that SenseMap supports). It also supports both 360 degree <a class="el" href="class_go_rogue_1_1_f_o_v.html" title="Class responsible for caculating basic FOV (see SenseMap for more advanced lighting). Effectively a simplified, slightly faster interface compared to SenseMap, that supports only a single source and only shadowcasting. This is more conducive to the typical use case for FOV. It can calculate the FOV with a finite or infinite max radius, and can use a variety of radius types, as specified in Radius class (all the same ones that SenseMap supports). It also supports both 360 degree FOV and a &quot;field of view&quot; (cone) FOV. One may access this class like a 2D array of doubles (FOV values), wherein the values will range from 0.0 to 1.0, where 1.0 means the corresponding map grid coordinate is at maximum visibility, and 0.0 means the cooresponding coordinate is outside of FOV entirely (not visible). ">FOV</a> and a "field of view" (cone) <a class="el" href="class_go_rogue_1_1_f_o_v.html" title="Class responsible for caculating basic FOV (see SenseMap for more advanced lighting). Effectively a simplified, slightly faster interface compared to SenseMap, that supports only a single source and only shadowcasting. This is more conducive to the typical use case for FOV. It can calculate the FOV with a finite or infinite max radius, and can use a variety of radius types, as specified in Radius class (all the same ones that SenseMap supports). It also supports both 360 degree FOV and a &quot;field of view&quot; (cone) FOV. One may access this class like a 2D array of doubles (FOV values), wherein the values will range from 0.0 to 1.0, where 1.0 means the corresponding map grid coordinate is at maximum visibility, and 0.0 means the cooresponding coordinate is outside of FOV entirely (not visible). ">FOV</a>. One may access this class like a 2D array of doubles (<a class="el" href="class_go_rogue_1_1_f_o_v.html" title="Class responsible for caculating basic FOV (see SenseMap for more advanced lighting). Effectively a simplified, slightly faster interface compared to SenseMap, that supports only a single source and only shadowcasting. This is more conducive to the typical use case for FOV. It can calculate the FOV with a finite or infinite max radius, and can use a variety of radius types, as specified in Radius class (all the same ones that SenseMap supports). It also supports both 360 degree FOV and a &quot;field of view&quot; (cone) FOV. One may access this class like a 2D array of doubles (FOV values), wherein the values will range from 0.0 to 1.0, where 1.0 means the corresponding map grid coordinate is at maximum visibility, and 0.0 means the cooresponding coordinate is outside of FOV entirely (not visible). ">FOV</a> values), wherein the values will range from 0.0 to 1.0, where 1.0 means the corresponding map grid coordinate is at maximum visibility, and 0.0 means the cooresponding coordinate is outside of <a class="el" href="class_go_rogue_1_1_f_o_v.html" title="Class responsible for caculating basic FOV (see SenseMap for more advanced lighting). Effectively a simplified, slightly faster interface compared to SenseMap, that supports only a single source and only shadowcasting. This is more conducive to the typical use case for FOV. It can calculate the FOV with a finite or infinite max radius, and can use a variety of radius types, as specified in Radius class (all the same ones that SenseMap supports). It also supports both 360 degree FOV and a &quot;field of view&quot; (cone) FOV. One may access this class like a 2D array of doubles (FOV values), wherein the values will range from 0.0 to 1.0, where 1.0 means the corresponding map grid coordinate is at maximum visibility, and 0.0 means the cooresponding coordinate is outside of FOV entirely (not visible). ">FOV</a> entirely (not visible).  <a href="class_go_rogue_1_1_f_o_v.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_go_rogue_1_1_i_d_generator.html">IDGenerator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class designed as a helper for situations where you need to generate and assign a unique integer to each instance of a class, eg. for a class implementing <a class="el" href="interface_go_rogue_1_1_i_has_i_d.html" title="Interface for a class that has an ID unique to all other instnaces of that class. Typical implementat...">IHasID</a> (see that interface documentation for usage example). One may initialize it with a starting unsigned integer, or 0 if none is specified. Then, every time one wants to use an integer, one should call <a class="el" href="class_go_rogue_1_1_i_d_generator.html#abb51a0e3fb8ab92d10f777efd1c252ee" title="Call every time you wish to &quot;assign&quot; an ID. The integer returned will never be returned again (each i...">UseID()</a>, and use the one it returns. It is not thread-safe on its own &ndash; if it needs to be, one might consider using a lock around any UseID calls.  <a href="class_go_rogue_1_1_i_d_generator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_go_rogue_1_1_i_has_i_d.html">IHasID</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for a class that has an ID unique to all other instnaces of that class. Typical implementation should involve using an <a class="el" href="class_go_rogue_1_1_i_d_generator.html" title="Class designed as a helper for situations where you need to generate and assign a unique integer to e...">IDGenerator</a>, potentially as follows:  <a href="interface_go_rogue_1_1_i_has_i_d.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_go_rogue_1_1_i_read_only_disjoint_set.html">IReadOnlyDisjointSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic read-only representation of a Disjoint set data structure. Assumes it is holding integers between 0 and size - 1.  <a href="interface_go_rogue_1_1_i_read_only_disjoint_set.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_go_rogue_1_1_i_read_only_f_o_v.html">IReadOnlyFOV</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read-only interface of the <a class="el" href="class_go_rogue_1_1_f_o_v.html" title="Class responsible for caculating basic FOV (see SenseMap for more advanced lighting). Effectively a simplified, slightly faster interface compared to SenseMap, that supports only a single source and only shadowcasting. This is more conducive to the typical use case for FOV. It can calculate the FOV with a finite or infinite max radius, and can use a variety of radius types, as specified in Radius class (all the same ones that SenseMap supports). It also supports both 360 degree FOV and a &quot;field of view&quot; (cone) FOV. One may access this class like a 2D array of doubles (FOV values), wherein the values will range from 0.0 to 1.0, where 1.0 means the corresponding map grid coordinate is at maximum visibility, and 0.0 means the cooresponding coordinate is outside of FOV entirely (not visible). ">FOV</a> class.  <a href="interface_go_rogue_1_1_i_read_only_f_o_v.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_go_rogue_1_1_i_read_only_radius_area_provider.html">IReadOnlyRadiusAreaProvider</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read-only interface of a <a class="el" href="class_go_rogue_1_1_radius_area_provider.html" title="Class capable of getting all unique positions inside of a given radius and (optional) bounds...">RadiusAreaProvider</a>.  <a href="interface_go_rogue_1_1_i_read_only_radius_area_provider.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_go_rogue_1_1_i_read_only_spatial_map.html">IReadOnlySpatialMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="interface_go_rogue_1_1_i_spatial_map.html" title="General interface for a data structure that records objects on a map. ">ISpatialMap</a> documentation. Similar in principle to the C# standard IReadOnlyList/IReadOnlyCollection interface. Simply exposes only those functions of the <a class="el" href="interface_go_rogue_1_1_i_spatial_map.html" title="General interface for a data structure that records objects on a map. ">ISpatialMap</a> interface that do not allow direct modification of the data (eg. adding/moving/removing items). This can allow for direct exposure of an <a class="el" href="interface_go_rogue_1_1_i_spatial_map.html" title="General interface for a data structure that records objects on a map. ">ISpatialMap</a> as a property of type <a class="el" href="interface_go_rogue_1_1_i_read_only_spatial_map.html" title="See ISpatialMap documentation. Similar in principle to the C# standard IReadOnlyList/IReadOnlyCollect...">IReadOnlySpatialMap</a>, without allowing such an exposure to break data encapsulation principles of something like a game map.  <a href="interface_go_rogue_1_1_i_read_only_spatial_map.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_go_rogue_1_1_i_spatial_map.html">ISpatialMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">General interface for a data structure that records objects on a map.  <a href="interface_go_rogue_1_1_i_spatial_map.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_go_rogue_1_1_i_spatial_tuple.html">ISpatialTuple</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface specifying return type for item-location pairs in a spatial map implementation.  <a href="interface_go_rogue_1_1_i_spatial_tuple.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_go_rogue_1_1_item_event_args.html">ItemEventArgs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event args for spatial map events pertaining to an item (item added, item removed, etc.)  <a href="class_go_rogue_1_1_item_event_args.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_go_rogue_1_1_item_moved_event_args.html">ItemMovedEventArgs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event args for <a class="el" href="class_go_rogue_1_1_spatial_map.html" title="Designed as an more efficient data structure for recording objects on a map. The simple version: if y...">SpatialMap</a>'s ItemMoved event.  <a href="class_go_rogue_1_1_item_moved_event_args.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_go_rogue_1_1_lines.html">Lines</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides implementations of various (line-drawing) algorithms for generating points closest to a line between two points on a grid.  <a href="class_go_rogue_1_1_lines.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_go_rogue_1_1_math_helpers.html">MathHelpers</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static class consisting of mathematical "helper" functions and constants &ndash; things like angle unit conversions, and other helpful functions.  <a href="class_go_rogue_1_1_math_helpers.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_go_rogue_1_1_multi_spatial_map.html">MultiSpatialMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="class_go_rogue_1_1_spatial_map.html" title="Designed as an more efficient data structure for recording objects on a map. The simple version: if y...">SpatialMap</a> documentation &ndash; similar in principle. However, this implementation allows multiple items to exist at one point in the <a class="el" href="class_go_rogue_1_1_spatial_map.html" title="Designed as an more efficient data structure for recording objects on a map. The simple version: if y...">SpatialMap</a>, in exchange for the loss of the convenience functions like GetItem vs GetItems, as well as potential performance differences (although unless the number of objects at any given location is large, the performance is asymptotically the same).  <a href="class_go_rogue_1_1_multi_spatial_map.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_go_rogue_1_1_radius.html">Radius</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing different radius types. Similar in architecture to <a class="el" href="class_go_rogue_1_1_coord.html" title="2d coordinate class. You cannot create instances of this class using a constructor – instead...">Coord</a> in architecture &ndash; it cannot be instantiated. Instead it simply has pre-allocated static variables for each type of radius, that should be used whenever a variable of type <a class="el" href="class_go_rogue_1_1_radius.html" title="Class representing different radius types. Similar in architecture to Coord in architecture – it can...">Radius</a> is required.  <a href="class_go_rogue_1_1_radius.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_go_rogue_1_1_radius_area_provider.html">RadiusAreaProvider</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class capable of getting all unique positions inside of a given radius and (optional) bounds.  <a href="class_go_rogue_1_1_radius_area_provider.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_go_rogue_1_1_rectangle.html">Rectangle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a rectangle in terms of grid squares. Provides numerous functions pertaining to area.  <a href="struct_go_rogue_1_1_rectangle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_go_rogue_1_1_spatial_map.html">SpatialMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Designed as an more efficient data structure for recording objects on a map. The simple version: if you're about to use a List to store a bunch of objects in your map, consider using this or <a class="el" href="class_go_rogue_1_1_multi_spatial_map.html" title="See SpatialMap documentation – similar in principle. However, this implementation allows multiple it...">MultiSpatialMap</a> instead! /// More detail: typical roguelikes will use a 2D array (or 1D array accessed as a 2D array), for terrain, and lists of objects for things like entities, items, etc. This is simple but ultimately not efficient; for example, in that implementation, determining if there is an object at a location takes an amount of time proportional to the number of objects in this list. However, the other simple option is to use an array with size equal to the size of the map (as many do for terrain) for all object lists. This is even less ideal, as in that case, the time to iterate over all objects becomes proportional to the size of the map (since one has to do that for rendering, ouch!), which is typically much larger than the number of objects in a list. This is the problem <a class="el" href="class_go_rogue_1_1_spatial_map.html" title="Designed as an more efficient data structure for recording objects on a map. The simple version: if y...">SpatialMap</a> is designed to solve. It provides fast, near-constant-time operations for getting the object at a location, adding entities, removing entities, and will allow you to iterate through all objects in the <a class="el" href="class_go_rogue_1_1_spatial_map.html" title="Designed as an more efficient data structure for recording objects on a map. The simple version: if y...">SpatialMap</a> in time proportional to the number of objects in it (the best possible). /// Effectively, it is a more efficient list for objects that have a position associated with them. This implementation can only allow one item at a given location at a time &ndash; for an implementation that allows multiple items, see <a class="el" href="class_go_rogue_1_1_multi_spatial_map.html" title="See SpatialMap documentation – similar in principle. However, this implementation allows multiple it...">MultiSpatialMap</a>. /// The objects stored in a <a class="el" href="class_go_rogue_1_1_spatial_map.html" title="Designed as an more efficient data structure for recording objects on a map. The simple version: if y...">SpatialMap</a> must implement the <a class="el" href="interface_go_rogue_1_1_i_has_i_d.html" title="Interface for a class that has an ID unique to all other instnaces of that class. Typical implementat...">IHasID</a> (see that interface's documentation for an easy implementation example). This is used internally to keep track of the objects, since uints are easily hashable.  <a href="class_go_rogue_1_1_spatial_map.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>SpatialTuple</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_go_rogue_1_1_utility.html">Utility</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static class full of miscellaneous helper methods.  <a href="class_go_rogue_1_1_utility.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.12
</small></address>
</body>
</html>
