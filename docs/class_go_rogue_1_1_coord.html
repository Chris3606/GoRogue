<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>GoRogue: GoRogue.Coord Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">GoRogue
   </div>
   <div id="projectbrief">C# roguelike/2D game utility library.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_go_rogue.html">GoRogue</a></li><li class="navelem"><a class="el" href="class_go_rogue_1_1_coord.html">Coord</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="class_go_rogue_1_1_coord-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">GoRogue.Coord Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>2d coordinate class. You cannot create instances of this class using a constructor &ndash; instead, use the Get function to create instances. Also provides numerous static functions to deal with grid/Coord-related math, operations, etc.  
 <a href="class_go_rogue_1_1_coord.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aee8eebff28c6d73c89629909c0d0aec8"><td class="memItemLeft" align="right" valign="top">override bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_go_rogue_1_1_coord.html#aee8eebff28c6d73c89629909c0d0aec8">Equals</a> (object obj)</td></tr>
<tr class="memdesc:aee8eebff28c6d73c89629909c0d0aec8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as operator == in this case; returns false if obj is not a <a class="el" href="class_go_rogue_1_1_coord.html" title="2d coordinate class. You cannot create instances of this class using a constructor – instead...">Coord</a>.  <a href="#aee8eebff28c6d73c89629909c0d0aec8">More...</a><br /></td></tr>
<tr class="separator:aee8eebff28c6d73c89629909c0d0aec8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc0cb4f91fb9942e4ecb7216a56ed240"><td class="memItemLeft" align="right" valign="top">override int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_go_rogue_1_1_coord.html#acc0cb4f91fb9942e4ecb7216a56ed240">GetHashCode</a> ()</td></tr>
<tr class="memdesc:acc0cb4f91fb9942e4ecb7216a56ed240"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a hash code for the <a class="el" href="class_go_rogue_1_1_coord.html" title="2d coordinate class. You cannot create instances of this class using a constructor – instead...">Coord</a>. The important parts: it should be fairly fast and it does not collide often. The details: it uses a seperate bit-mixing algorithm for X and Y, with X and Y each multiplied by a differet large integer, then xors the mixed values, and does a right shift, then multiplies by an overflowing prime number.  <a href="#acc0cb4f91fb9942e4ecb7216a56ed240">More...</a><br /></td></tr>
<tr class="separator:acc0cb4f91fb9942e4ecb7216a56ed240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cd118940e45c6b28da8765771661096"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_go_rogue_1_1_coord.html#a8cd118940e45c6b28da8765771661096">ToIndex</a> (int rowCount)</td></tr>
<tr class="memdesc:a8cd118940e45c6b28da8765771661096"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a value that can be used to index this location in a 2D array that is actually encoded in a 1D array. Actual value is Y * rowCount + X. The 2D array being represented should have [width, height] of [rowCount, dontCare] for this index to be valid. Note that, when this method is used, if one needs to use a nested for loop to iterate over this array, it is best to do for y... as the outer loop and for x..., as the inner loop, for cache performance reasons.  <a href="#a8cd118940e45c6b28da8765771661096">More...</a><br /></td></tr>
<tr class="separator:a8cd118940e45c6b28da8765771661096"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdf9814ccd98c262780beaf4d5774aa5"><td class="memItemLeft" align="right" valign="top">override string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_go_rogue_1_1_coord.html#abdf9814ccd98c262780beaf4d5774aa5">ToString</a> ()</td></tr>
<tr class="memdesc:abdf9814ccd98c262780beaf4d5774aa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns representation (X, Y).  <a href="#abdf9814ccd98c262780beaf4d5774aa5">More...</a><br /></td></tr>
<tr class="separator:abdf9814ccd98c262780beaf4d5774aa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad678b722d6d7c673cfd1525ab1aa3adb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_go_rogue_1_1_coord.html">Coord</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_go_rogue_1_1_coord.html#ad678b722d6d7c673cfd1525ab1aa3adb">Translate</a> (int dx, int dy)</td></tr>
<tr class="memdesc:ad678b722d6d7c673cfd1525ab1aa3adb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the coordinate resulting from adding dx to the X-value of the coordinate, and dy to the Y-value of the coordinate, eg. (X + dx, Y + dy). Provided for convenience.  <a href="#ad678b722d6d7c673cfd1525ab1aa3adb">More...</a><br /></td></tr>
<tr class="separator:ad678b722d6d7c673cfd1525ab1aa3adb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:adc18a8b7d151eb1ea243fb815757e1b9"><td class="memItemLeft" align="right" valign="top">static IEnumerable&lt; <a class="el" href="class_go_rogue_1_1_coord.html">Coord</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_go_rogue_1_1_coord.html#adc18a8b7d151eb1ea243fb815757e1b9">AllNeighbors</a> (<a class="el" href="class_go_rogue_1_1_coord.html">Coord</a> startingLocation)</td></tr>
<tr class="memdesc:adc18a8b7d151eb1ea243fb815757e1b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets all 8 neighbors of the given location, cardinals before diagonals.  <a href="#adc18a8b7d151eb1ea243fb815757e1b9">More...</a><br /></td></tr>
<tr class="separator:adc18a8b7d151eb1ea243fb815757e1b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24ea92d10a206078748baf2c99891686"><td class="memItemLeft" align="right" valign="top">static IEnumerable&lt; <a class="el" href="class_go_rogue_1_1_coord.html">Coord</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_go_rogue_1_1_coord.html#a24ea92d10a206078748baf2c99891686">AllNeighbors</a> (int startingX, int startingY)</td></tr>
<tr class="memdesc:a24ea92d10a206078748baf2c99891686"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets all 8 neighbors of the given location, cardinals before diagonals.  <a href="#a24ea92d10a206078748baf2c99891686">More...</a><br /></td></tr>
<tr class="separator:a24ea92d10a206078748baf2c99891686"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa3008c1315af2d5a8cbdd7949c0370f"><td class="memItemLeft" align="right" valign="top">static IEnumerable&lt; <a class="el" href="class_go_rogue_1_1_coord.html">Coord</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_go_rogue_1_1_coord.html#aaa3008c1315af2d5a8cbdd7949c0370f">AllNeighborsClockwise</a> (<a class="el" href="class_go_rogue_1_1_coord.html">Coord</a> startingLocation, <a class="el" href="class_go_rogue_1_1_direction.html">Direction</a> startingDirection=null)</td></tr>
<tr class="memdesc:aaa3008c1315af2d5a8cbdd7949c0370f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets all 8 neighbors of the given location, in clockwise order, starting with the neighbor in the direction given (or UP by default).  <a href="#aaa3008c1315af2d5a8cbdd7949c0370f">More...</a><br /></td></tr>
<tr class="separator:aaa3008c1315af2d5a8cbdd7949c0370f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93f0ff8ae8581498e441ca7881a66fb7"><td class="memItemLeft" align="right" valign="top">static IEnumerable&lt; <a class="el" href="class_go_rogue_1_1_coord.html">Coord</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_go_rogue_1_1_coord.html#a93f0ff8ae8581498e441ca7881a66fb7">AllNeighborsClockwise</a> (int startingX, int startingY, <a class="el" href="class_go_rogue_1_1_direction.html">Direction</a> startingDirection=null)</td></tr>
<tr class="memdesc:a93f0ff8ae8581498e441ca7881a66fb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets all 8 neighbors of the given location, in clockwise order, starting with the neighbor in the direction given (or UP by default).  <a href="#a93f0ff8ae8581498e441ca7881a66fb7">More...</a><br /></td></tr>
<tr class="separator:a93f0ff8ae8581498e441ca7881a66fb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af63ecf35dbd3ed322352e394d13e0315"><td class="memItemLeft" align="right" valign="top">static IEnumerable&lt; <a class="el" href="class_go_rogue_1_1_coord.html">Coord</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_go_rogue_1_1_coord.html#af63ecf35dbd3ed322352e394d13e0315">AllNeighborsCounterClockwise</a> (<a class="el" href="class_go_rogue_1_1_coord.html">Coord</a> startingLocation, <a class="el" href="class_go_rogue_1_1_direction.html">Direction</a> startingDirection=null)</td></tr>
<tr class="memdesc:af63ecf35dbd3ed322352e394d13e0315"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets all 8 neighbors of the given location, in counter-clockwise order, starting with the neighbor in the direction given (or UP by default).  <a href="#af63ecf35dbd3ed322352e394d13e0315">More...</a><br /></td></tr>
<tr class="separator:af63ecf35dbd3ed322352e394d13e0315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e878e0d330818ffc327e893f38289a6"><td class="memItemLeft" align="right" valign="top">static IEnumerable&lt; <a class="el" href="class_go_rogue_1_1_coord.html">Coord</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_go_rogue_1_1_coord.html#a1e878e0d330818ffc327e893f38289a6">AllNeighborsCounterClockwise</a> (int startingX, int startingY, <a class="el" href="class_go_rogue_1_1_direction.html">Direction</a> startingDirection=null)</td></tr>
<tr class="memdesc:a1e878e0d330818ffc327e893f38289a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets all 8 neighbors of the given location, in counter-clockwise order, starting with the neighbor in the direction given (or UP by default).  <a href="#a1e878e0d330818ffc327e893f38289a6">More...</a><br /></td></tr>
<tr class="separator:a1e878e0d330818ffc327e893f38289a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33dc72791c581e8231a1637ac9262b62"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_go_rogue_1_1_coord.html#a33dc72791c581e8231a1637ac9262b62">BearingOfLine</a> (<a class="el" href="class_go_rogue_1_1_coord.html">Coord</a> from, <a class="el" href="class_go_rogue_1_1_coord.html">Coord</a> to)</td></tr>
<tr class="memdesc:a33dc72791c581e8231a1637ac9262b62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates degree bearing of the line (from =&gt; to), where 0 is the direction <a class="el" href="class_go_rogue_1_1_direction.html#a86c2b981e6a3a6f2d13a190b4beec0cc" title="Up direction. ">Direction.UP</a>.  <a href="#a33dc72791c581e8231a1637ac9262b62">More...</a><br /></td></tr>
<tr class="separator:a33dc72791c581e8231a1637ac9262b62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acccbce826e899402628d28e73b8f6e56"><td class="memItemLeft" align="right" valign="top">static IEnumerable&lt; <a class="el" href="class_go_rogue_1_1_coord.html">Coord</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_go_rogue_1_1_coord.html#acccbce826e899402628d28e73b8f6e56">CardinalNeighbors</a> (<a class="el" href="class_go_rogue_1_1_coord.html">Coord</a> startingLocation)</td></tr>
<tr class="memdesc:acccbce826e899402628d28e73b8f6e56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the 4 cardinal neighbors of the given location, in order UP, DOWN, LEFT, RIGHT.  <a href="#acccbce826e899402628d28e73b8f6e56">More...</a><br /></td></tr>
<tr class="separator:acccbce826e899402628d28e73b8f6e56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfcb56f960646057780fbf63cdf997ff"><td class="memItemLeft" align="right" valign="top">static IEnumerable&lt; <a class="el" href="class_go_rogue_1_1_coord.html">Coord</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_go_rogue_1_1_coord.html#abfcb56f960646057780fbf63cdf997ff">CardinalNeighbors</a> (int startingX, int startingY)</td></tr>
<tr class="memdesc:abfcb56f960646057780fbf63cdf997ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the 4 cardinal neighbors of the given location, in order UP, DOWN, LEFT, RIGHT.  <a href="#abfcb56f960646057780fbf63cdf997ff">More...</a><br /></td></tr>
<tr class="separator:abfcb56f960646057780fbf63cdf997ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebec8f932d00e6bdcc9e06dc6ccbced8"><td class="memItemLeft" align="right" valign="top">static IEnumerable&lt; <a class="el" href="class_go_rogue_1_1_coord.html">Coord</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_go_rogue_1_1_coord.html#aebec8f932d00e6bdcc9e06dc6ccbced8">CardinalNeighborsClockwise</a> (<a class="el" href="class_go_rogue_1_1_coord.html">Coord</a> startingLocation, <a class="el" href="class_go_rogue_1_1_direction.html">Direction</a> startingDirection=null)</td></tr>
<tr class="memdesc:aebec8f932d00e6bdcc9e06dc6ccbced8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the 4 cardinal neighbors of the given location, in clockwise order, starting with the neighbor in the direction given (or UP by default). If the direction given is a diagonal, it starts with the closest clockwise cardinal neighbor.  <a href="#aebec8f932d00e6bdcc9e06dc6ccbced8">More...</a><br /></td></tr>
<tr class="separator:aebec8f932d00e6bdcc9e06dc6ccbced8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36d510d3dfb2d29f760203f01b91be1b"><td class="memItemLeft" align="right" valign="top">static IEnumerable&lt; <a class="el" href="class_go_rogue_1_1_coord.html">Coord</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_go_rogue_1_1_coord.html#a36d510d3dfb2d29f760203f01b91be1b">CardinalNeighborsClockwise</a> (int startingX, int startingY, <a class="el" href="class_go_rogue_1_1_direction.html">Direction</a> startingDirection=null)</td></tr>
<tr class="memdesc:a36d510d3dfb2d29f760203f01b91be1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the 4 cardinal neighbors of the given location, in clockwise order, starting with the neighbor in the direction given (or UP by default). If the direction given is a diagonal, it starts with the closest clockwise cardinal neighbor.  <a href="#a36d510d3dfb2d29f760203f01b91be1b">More...</a><br /></td></tr>
<tr class="separator:a36d510d3dfb2d29f760203f01b91be1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2087fb4e544a66f6423fbf2ec07e9d98"><td class="memItemLeft" align="right" valign="top">static IEnumerable&lt; <a class="el" href="class_go_rogue_1_1_coord.html">Coord</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_go_rogue_1_1_coord.html#a2087fb4e544a66f6423fbf2ec07e9d98">CardinalNeighborsCounterClockwise</a> (<a class="el" href="class_go_rogue_1_1_coord.html">Coord</a> startingLocation, <a class="el" href="class_go_rogue_1_1_direction.html">Direction</a> startingDirection=null)</td></tr>
<tr class="memdesc:a2087fb4e544a66f6423fbf2ec07e9d98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the 4 cardinal neighbors of the given location, in counter-clockwise order, starting with the neighbor in the direction given (or UP by default). If the direction given is a diagonal, it starts with the closest counter-clockwise cardinal neighbor.  <a href="#a2087fb4e544a66f6423fbf2ec07e9d98">More...</a><br /></td></tr>
<tr class="separator:a2087fb4e544a66f6423fbf2ec07e9d98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b1385d15bf6e9337139f16d23ddd6c4"><td class="memItemLeft" align="right" valign="top">static IEnumerable&lt; <a class="el" href="class_go_rogue_1_1_coord.html">Coord</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_go_rogue_1_1_coord.html#a9b1385d15bf6e9337139f16d23ddd6c4">CardinalNeighborsCounterClockwise</a> (int startingX, int startingY, <a class="el" href="class_go_rogue_1_1_direction.html">Direction</a> startingDirection=null)</td></tr>
<tr class="memdesc:a9b1385d15bf6e9337139f16d23ddd6c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the 4 cardinal neighbors of the given location, in counter-clockwise order, starting with the neighbor in the direction given (or UP by default). If the direction given is a diagonal, it starts with the closest counter-clockwise cardinal neighbor.  <a href="#a9b1385d15bf6e9337139f16d23ddd6c4">More...</a><br /></td></tr>
<tr class="separator:a9b1385d15bf6e9337139f16d23ddd6c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57da954d429fe425077ea6278abe343f"><td class="memItemLeft" align="right" valign="top">static IEnumerable&lt; <a class="el" href="class_go_rogue_1_1_coord.html">Coord</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_go_rogue_1_1_coord.html#a57da954d429fe425077ea6278abe343f">DiagonalNeighbors</a> (<a class="el" href="class_go_rogue_1_1_coord.html">Coord</a> startingLocation)</td></tr>
<tr class="memdesc:a57da954d429fe425077ea6278abe343f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the 4 diagonal neighbors of the given location, in order UP_LEFT, UP_RIGHT, DOWN_LEFT, DOWN_RIGHT.  <a href="#a57da954d429fe425077ea6278abe343f">More...</a><br /></td></tr>
<tr class="separator:a57da954d429fe425077ea6278abe343f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0364d75d0b8897f505f87473cb4a1502"><td class="memItemLeft" align="right" valign="top">static IEnumerable&lt; <a class="el" href="class_go_rogue_1_1_coord.html">Coord</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_go_rogue_1_1_coord.html#a0364d75d0b8897f505f87473cb4a1502">DiagonalNeighbors</a> (int startingX, int startingY)</td></tr>
<tr class="memdesc:a0364d75d0b8897f505f87473cb4a1502"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the 4 diagonal neighbors of the given location, in order UP_LEFT, UP_RIGHT, DOWN_LEFT, DOWN_RIGHT.  <a href="#a0364d75d0b8897f505f87473cb4a1502">More...</a><br /></td></tr>
<tr class="separator:a0364d75d0b8897f505f87473cb4a1502"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24a54b350e2059752201b95897c7deb6"><td class="memItemLeft" align="right" valign="top">static IEnumerable&lt; <a class="el" href="class_go_rogue_1_1_coord.html">Coord</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_go_rogue_1_1_coord.html#a24a54b350e2059752201b95897c7deb6">DiagonalNeighborsClockwise</a> (<a class="el" href="class_go_rogue_1_1_coord.html">Coord</a> startingLocation, <a class="el" href="class_go_rogue_1_1_direction.html">Direction</a> startingDirection=null)</td></tr>
<tr class="memdesc:a24a54b350e2059752201b95897c7deb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the 4 diagonal neighbors of the given location, in clockwise order, starting with the neighbor in the direction given (or UP_RIGHT by default). If the direction given is a cardinal, it starts with the closest clockwise diagonal neighbor.  <a href="#a24a54b350e2059752201b95897c7deb6">More...</a><br /></td></tr>
<tr class="separator:a24a54b350e2059752201b95897c7deb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a862d1eb729e8c084223e6f985496ca35"><td class="memItemLeft" align="right" valign="top">static IEnumerable&lt; <a class="el" href="class_go_rogue_1_1_coord.html">Coord</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_go_rogue_1_1_coord.html#a862d1eb729e8c084223e6f985496ca35">DiagonalNeighborsClockwise</a> (int startingX, int startingY, <a class="el" href="class_go_rogue_1_1_direction.html">Direction</a> startingDirection=null)</td></tr>
<tr class="memdesc:a862d1eb729e8c084223e6f985496ca35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the 4 diagonal neighbors of the given location, in clockwise order, starting with the neighbor in the direction given (or UP_RIGHT by default). If the direction given is a cardinal, it starts with the closest clockwise diagonal neighbor.  <a href="#a862d1eb729e8c084223e6f985496ca35">More...</a><br /></td></tr>
<tr class="separator:a862d1eb729e8c084223e6f985496ca35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e97444616c3e46c0731971e2cd09365"><td class="memItemLeft" align="right" valign="top">static IEnumerable&lt; <a class="el" href="class_go_rogue_1_1_coord.html">Coord</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_go_rogue_1_1_coord.html#a6e97444616c3e46c0731971e2cd09365">DiagonalNeighborsCounterClockwise</a> (<a class="el" href="class_go_rogue_1_1_coord.html">Coord</a> startingLocation, <a class="el" href="class_go_rogue_1_1_direction.html">Direction</a> startingDirection=null)</td></tr>
<tr class="memdesc:a6e97444616c3e46c0731971e2cd09365"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the 4 diagonal neighbors of the given location, in counter-clockwise order, starting with the neighbor in the direction given (or UP_LEFT by default). If the direction given is a cardinal, it starts with the closest counter-clockwise diagonal neighbor.  <a href="#a6e97444616c3e46c0731971e2cd09365">More...</a><br /></td></tr>
<tr class="separator:a6e97444616c3e46c0731971e2cd09365"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c0b5c1c7a5097f34ed580202b589736"><td class="memItemLeft" align="right" valign="top">static IEnumerable&lt; <a class="el" href="class_go_rogue_1_1_coord.html">Coord</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_go_rogue_1_1_coord.html#a5c0b5c1c7a5097f34ed580202b589736">DiagonalNeighborsCounterClockwise</a> (int startingX, int startingY, <a class="el" href="class_go_rogue_1_1_direction.html">Direction</a> startingDirection=null)</td></tr>
<tr class="memdesc:a5c0b5c1c7a5097f34ed580202b589736"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the 4 diagonal neighbors of the given location, in counter-clockwise order, starting with the neighbor in the direction given (or UP_LEFT by default). If the direction given is a cardinal, it starts with the closest counter-clockwise diagonal neighbor.  <a href="#a5c0b5c1c7a5097f34ed580202b589736">More...</a><br /></td></tr>
<tr class="separator:a5c0b5c1c7a5097f34ed580202b589736"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ecee2b7034831c1d701bf40b7af3764"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_go_rogue_1_1_coord.html#a1ecee2b7034831c1d701bf40b7af3764">EuclideanDistanceMagnitude</a> (<a class="el" href="class_go_rogue_1_1_coord.html">Coord</a> c1, <a class="el" href="class_go_rogue_1_1_coord.html">Coord</a> c2)</td></tr>
<tr class="memdesc:a1ecee2b7034831c1d701bf40b7af3764"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the result of the euclidean distance formula, without the square root &ndash; eg., (c2.X - c1.X) * (c2.X - c1.X) + (c2.Y - c1.Y) * (c2.Y - c1.Y). Use this if you only care about the magnitude of the distance &ndash; eg., if you're trying to compare two distances. Omitting the square root provides a speed increase.  <a href="#a1ecee2b7034831c1d701bf40b7af3764">More...</a><br /></td></tr>
<tr class="separator:a1ecee2b7034831c1d701bf40b7af3764"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae25bcfd7c2943acb6de3431c6c33a423"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_go_rogue_1_1_coord.html">Coord</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_go_rogue_1_1_coord.html#ae25bcfd7c2943acb6de3431c6c33a423">Get</a> (int x, int y)</td></tr>
<tr class="memdesc:ae25bcfd7c2943acb6de3431c6c33a423"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the proper <a class="el" href="class_go_rogue_1_1_coord.html" title="2d coordinate class. You cannot create instances of this class using a constructor – instead...">Coord</a> instance for the given x and y values. Will return the one in the array if the values are in the appropriate range, otherwise will create a new one and return that one.  <a href="#ae25bcfd7c2943acb6de3431c6c33a423">More...</a><br /></td></tr>
<tr class="separator:ae25bcfd7c2943acb6de3431c6c33a423"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2c2d73d6057f120ecd3628428cdea45"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_go_rogue_1_1_coord.html">Coord</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_go_rogue_1_1_coord.html#ae2c2d73d6057f120ecd3628428cdea45">Midpoint</a> (<a class="el" href="class_go_rogue_1_1_coord.html">Coord</a> c1, <a class="el" href="class_go_rogue_1_1_coord.html">Coord</a> c2)</td></tr>
<tr class="memdesc:ae2c2d73d6057f120ecd3628428cdea45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the midpoint between the two points.  <a href="#ae2c2d73d6057f120ecd3628428cdea45">More...</a><br /></td></tr>
<tr class="separator:ae2c2d73d6057f120ecd3628428cdea45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad81e63c68df26f28d73fd907a9b58338"><td class="memItemLeft" align="right" valign="top">static IEnumerable&lt; <a class="el" href="class_go_rogue_1_1_coord.html">Coord</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_go_rogue_1_1_coord.html#ad81e63c68df26f28d73fd907a9b58338">Neighbors</a> (<a class="el" href="class_go_rogue_1_1_coord.html">Coord</a> startingLocation, <a class="el" href="class_go_rogue_1_1_distance.html">Distance</a> distanceCalc)</td></tr>
<tr class="memdesc:ad81e63c68df26f28d73fd907a9b58338"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets all neighbors of the specified location, based on the distance calculation specified (MANHATTAN yields 4 neighbors, others yield 8, with cardinals returned before diagonals).  <a href="#ad81e63c68df26f28d73fd907a9b58338">More...</a><br /></td></tr>
<tr class="separator:ad81e63c68df26f28d73fd907a9b58338"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9068eeda71406bfc7bfdd8ae4bed4525"><td class="memItemLeft" align="right" valign="top">static IEnumerable&lt; <a class="el" href="class_go_rogue_1_1_coord.html">Coord</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_go_rogue_1_1_coord.html#a9068eeda71406bfc7bfdd8ae4bed4525">Neighbors</a> (int startingX, int startingY, <a class="el" href="class_go_rogue_1_1_distance.html">Distance</a> distanceCalc)</td></tr>
<tr class="memdesc:a9068eeda71406bfc7bfdd8ae4bed4525"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets all neighbors of the specified location, based on the distance calculation specified (MANHATTAN yields 4 neighbors, others yield 8, with cardinals returned before diagonals).  <a href="#a9068eeda71406bfc7bfdd8ae4bed4525">More...</a><br /></td></tr>
<tr class="separator:a9068eeda71406bfc7bfdd8ae4bed4525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e4d84d3ccbade2c89ec9413d9223b64"><td class="memItemLeft" align="right" valign="top">static IEnumerable&lt; <a class="el" href="class_go_rogue_1_1_coord.html">Coord</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_go_rogue_1_1_coord.html#a1e4d84d3ccbade2c89ec9413d9223b64">Neighbors</a> (<a class="el" href="class_go_rogue_1_1_coord.html">Coord</a> startingLocation, <a class="el" href="class_go_rogue_1_1_radius.html">Radius</a> shape)</td></tr>
<tr class="memdesc:a1e4d84d3ccbade2c89ec9413d9223b64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets all neighbors of the specified location, based on the radius shape specified (DIAMOND/OCTAHEDRON yields 4 neighbors, others yield 8, with cardinals returned before diagonals).  <a href="#a1e4d84d3ccbade2c89ec9413d9223b64">More...</a><br /></td></tr>
<tr class="separator:a1e4d84d3ccbade2c89ec9413d9223b64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8d2f81643b97d137e517fc424dc5023"><td class="memItemLeft" align="right" valign="top">static IEnumerable&lt; <a class="el" href="class_go_rogue_1_1_coord.html">Coord</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_go_rogue_1_1_coord.html#aa8d2f81643b97d137e517fc424dc5023">Neighbors</a> (int startingX, int startingY, <a class="el" href="class_go_rogue_1_1_radius.html">Radius</a> shape)</td></tr>
<tr class="memdesc:aa8d2f81643b97d137e517fc424dc5023"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets all neighbors of the specified location, based on the radius shape specified (DIAMOND/OCTAHEDRON yields 4 neighbors, others yield 8, with cardinals returned before diagonals).  <a href="#aa8d2f81643b97d137e517fc424dc5023">More...</a><br /></td></tr>
<tr class="separator:aa8d2f81643b97d137e517fc424dc5023"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91f47d9c4a3b355a5786c137a5c490ce"><td class="memItemLeft" align="right" valign="top">static IEnumerable&lt; <a class="el" href="class_go_rogue_1_1_coord.html">Coord</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_go_rogue_1_1_coord.html#a91f47d9c4a3b355a5786c137a5c490ce">NeighborsClockwise</a> (<a class="el" href="class_go_rogue_1_1_coord.html">Coord</a> startingLocation, <a class="el" href="class_go_rogue_1_1_distance.html">Distance</a> distanceCalc, <a class="el" href="class_go_rogue_1_1_direction.html">Direction</a> startingDirection=null)</td></tr>
<tr class="memdesc:a91f47d9c4a3b355a5786c137a5c490ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets all neighbors of the specified location, in clockwise order, based on the distance calculation specified (MANHATTAN yields 4 neighbors, others yield 8). The first direction returned is the one specified as startingDirection, or the closest clockwise cardinal if it is a diagonal and MANHATTAN is used.  <a href="#a91f47d9c4a3b355a5786c137a5c490ce">More...</a><br /></td></tr>
<tr class="separator:a91f47d9c4a3b355a5786c137a5c490ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87ce525c63d524f75212884a1e5da8be"><td class="memItemLeft" align="right" valign="top">static IEnumerable&lt; <a class="el" href="class_go_rogue_1_1_coord.html">Coord</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_go_rogue_1_1_coord.html#a87ce525c63d524f75212884a1e5da8be">NeighborsClockwise</a> (int startingX, int startingY, <a class="el" href="class_go_rogue_1_1_distance.html">Distance</a> distanceCalc, <a class="el" href="class_go_rogue_1_1_direction.html">Direction</a> startingDirection=null)</td></tr>
<tr class="memdesc:a87ce525c63d524f75212884a1e5da8be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets all neighbors of the specified location, in clockwise order, based on the distance calculation specified (MANHATTAN yields 4 neighbors, others yield 8). The first direction returned is the one specified as startingDirection, or the closest clockwise cardinal if it is a diagonal and MANHATTAN is used.  <a href="#a87ce525c63d524f75212884a1e5da8be">More...</a><br /></td></tr>
<tr class="separator:a87ce525c63d524f75212884a1e5da8be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b28efc6644df5b8a994726e8000653b"><td class="memItemLeft" align="right" valign="top">static IEnumerable&lt; <a class="el" href="class_go_rogue_1_1_coord.html">Coord</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_go_rogue_1_1_coord.html#a1b28efc6644df5b8a994726e8000653b">NeighborsClockwise</a> (<a class="el" href="class_go_rogue_1_1_coord.html">Coord</a> startingLocation, <a class="el" href="class_go_rogue_1_1_radius.html">Radius</a> shape, <a class="el" href="class_go_rogue_1_1_direction.html">Direction</a> startingDirection=null)</td></tr>
<tr class="memdesc:a1b28efc6644df5b8a994726e8000653b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets all neighbors of the specified location, in clockwise order, based on the radius shape specified (DIAMOND/OCTAHEDRON yields 4 neighbors, others yield 8). The first direction returned is the one specified as startingDirection, or the closest clockwise cardinal if it is a diagonal and DIAMOND/OCTAHEDRON is used.  <a href="#a1b28efc6644df5b8a994726e8000653b">More...</a><br /></td></tr>
<tr class="separator:a1b28efc6644df5b8a994726e8000653b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0d6bcab1a0e8cdcdcb215a0083b743c"><td class="memItemLeft" align="right" valign="top">static IEnumerable&lt; <a class="el" href="class_go_rogue_1_1_coord.html">Coord</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_go_rogue_1_1_coord.html#ac0d6bcab1a0e8cdcdcb215a0083b743c">NeighborsClockwise</a> (int startingX, int startingY, <a class="el" href="class_go_rogue_1_1_radius.html">Radius</a> shape, <a class="el" href="class_go_rogue_1_1_direction.html">Direction</a> startingDirection=null)</td></tr>
<tr class="memdesc:ac0d6bcab1a0e8cdcdcb215a0083b743c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets all neighbors of the specified location, in clockwise order, based on the radius shape specified (DIAMOND/OCTAHEDRON yields 4 neighbors, others yield 8). The first direction returned is the one specified as startingDirection, or the closest clockwise cardinal if it is a diagonal and DIAMOND/OCTAHEDRON is used.  <a href="#ac0d6bcab1a0e8cdcdcb215a0083b743c">More...</a><br /></td></tr>
<tr class="separator:ac0d6bcab1a0e8cdcdcb215a0083b743c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b6383d28729f1e19a300046627f44b0"><td class="memItemLeft" align="right" valign="top">static IEnumerable&lt; <a class="el" href="class_go_rogue_1_1_coord.html">Coord</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_go_rogue_1_1_coord.html#a2b6383d28729f1e19a300046627f44b0">NeighborsCounterClockwise</a> (<a class="el" href="class_go_rogue_1_1_coord.html">Coord</a> startingLocation, <a class="el" href="class_go_rogue_1_1_distance.html">Distance</a> distanceCalc, <a class="el" href="class_go_rogue_1_1_direction.html">Direction</a> startingDirection=null)</td></tr>
<tr class="memdesc:a2b6383d28729f1e19a300046627f44b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets all neighbors of the specified location, in counter-clockwise order, based on the distance calculation specified (MANHATTAN yields 4 neighbors, others yield 8). The first direction returned is the one specified as startingDirection, or the closest counter-clockwise cardinal if it is a diagonal and MANHATTAN is used.  <a href="#a2b6383d28729f1e19a300046627f44b0">More...</a><br /></td></tr>
<tr class="separator:a2b6383d28729f1e19a300046627f44b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55407cf6cb7a3226d076b5ce642afac1"><td class="memItemLeft" align="right" valign="top">static IEnumerable&lt; <a class="el" href="class_go_rogue_1_1_coord.html">Coord</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_go_rogue_1_1_coord.html#a55407cf6cb7a3226d076b5ce642afac1">NeighborsCounterClockwise</a> (int startingX, int startingY, <a class="el" href="class_go_rogue_1_1_distance.html">Distance</a> distanceCalc, <a class="el" href="class_go_rogue_1_1_direction.html">Direction</a> startingDirection=null)</td></tr>
<tr class="memdesc:a55407cf6cb7a3226d076b5ce642afac1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets all neighbors of the specified location, in counter-clockwise order, based on the distance calculation specified (MANHATTAN yields 4 neighbors, others yield 8). The first direction returned is the one specified as startingDirection, or the closest counter-clockwise cardinal if it is a diagonal and MANHATTAN is used.  <a href="#a55407cf6cb7a3226d076b5ce642afac1">More...</a><br /></td></tr>
<tr class="separator:a55407cf6cb7a3226d076b5ce642afac1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3d5c076db6efebe3f1def8640ce316e"><td class="memItemLeft" align="right" valign="top">static IEnumerable&lt; <a class="el" href="class_go_rogue_1_1_coord.html">Coord</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_go_rogue_1_1_coord.html#ae3d5c076db6efebe3f1def8640ce316e">NeighborsCounterClockwise</a> (<a class="el" href="class_go_rogue_1_1_coord.html">Coord</a> startingLocation, <a class="el" href="class_go_rogue_1_1_radius.html">Radius</a> shape, <a class="el" href="class_go_rogue_1_1_direction.html">Direction</a> startingDirection=null)</td></tr>
<tr class="memdesc:ae3d5c076db6efebe3f1def8640ce316e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets all neighbors of the specified location, in counter-clockwise order, based on the radius shape specified (DIAMOND/OCTAHEDRON yields 4 neighbors, others yield 8). The first direction returned is the one specified as startingDirection, or the closest counter-clockwise cardinal if it is a diagonal and DIAMOND/OCTAHEDRON is used.  <a href="#ae3d5c076db6efebe3f1def8640ce316e">More...</a><br /></td></tr>
<tr class="separator:ae3d5c076db6efebe3f1def8640ce316e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0875304dcc50a35dbb4c3d8fe9e01b4"><td class="memItemLeft" align="right" valign="top">static IEnumerable&lt; <a class="el" href="class_go_rogue_1_1_coord.html">Coord</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_go_rogue_1_1_coord.html#ab0875304dcc50a35dbb4c3d8fe9e01b4">NeighborsCounterClockwise</a> (int startingX, int startingY, <a class="el" href="class_go_rogue_1_1_radius.html">Radius</a> shape, <a class="el" href="class_go_rogue_1_1_direction.html">Direction</a> startingDirection=null)</td></tr>
<tr class="memdesc:ab0875304dcc50a35dbb4c3d8fe9e01b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets all neighbors of the specified location, in counter-clockwise order, based on the radius shape specified (DIAMOND/OCTAHEDRON yields 4 neighbors, others yield 8). The first direction returned is the one specified as startingDirection, or the closest counter-clockwise cardinal if it is a diagonal and DIAMOND/OCTAHEDRON is used.  <a href="#ab0875304dcc50a35dbb4c3d8fe9e01b4">More...</a><br /></td></tr>
<tr class="separator:ab0875304dcc50a35dbb4c3d8fe9e01b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b9654ccdac1e2b628b5aeae8f574455"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_go_rogue_1_1_coord.html">Coord</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_go_rogue_1_1_coord.html#a3b9654ccdac1e2b628b5aeae8f574455">operator-</a> (<a class="el" href="class_go_rogue_1_1_coord.html">Coord</a> c1, <a class="el" href="class_go_rogue_1_1_coord.html">Coord</a> c2)</td></tr>
<tr class="separator:a3b9654ccdac1e2b628b5aeae8f574455"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab049f69b3505dc4b1328fcb489cb51c9"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_go_rogue_1_1_coord.html">Coord</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_go_rogue_1_1_coord.html#ab049f69b3505dc4b1328fcb489cb51c9">operator-</a> (<a class="el" href="class_go_rogue_1_1_coord.html">Coord</a> c, int i)</td></tr>
<tr class="separator:ab049f69b3505dc4b1328fcb489cb51c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1965e10afb1c163c932945c8bbfca8c1"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_go_rogue_1_1_coord.html#a1965e10afb1c163c932945c8bbfca8c1">operator!=</a> (<a class="el" href="class_go_rogue_1_1_coord.html">Coord</a> c1, <a class="el" href="class_go_rogue_1_1_coord.html">Coord</a> c2)</td></tr>
<tr class="memdesc:a1965e10afb1c163c932945c8bbfca8c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if either the x-values or y-values are not equal.  <a href="#a1965e10afb1c163c932945c8bbfca8c1">More...</a><br /></td></tr>
<tr class="separator:a1965e10afb1c163c932945c8bbfca8c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f5605039303c71b3ee33b10223a8173"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_go_rogue_1_1_coord.html">Coord</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_go_rogue_1_1_coord.html#a4f5605039303c71b3ee33b10223a8173">operator*</a> (<a class="el" href="class_go_rogue_1_1_coord.html">Coord</a> c, int i)</td></tr>
<tr class="separator:a4f5605039303c71b3ee33b10223a8173"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab96c645fe4ae9e70282e7ebae44db0c0"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_go_rogue_1_1_coord.html">Coord</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_go_rogue_1_1_coord.html#ab96c645fe4ae9e70282e7ebae44db0c0">operator*</a> (<a class="el" href="class_go_rogue_1_1_coord.html">Coord</a> c, double i)</td></tr>
<tr class="separator:ab96c645fe4ae9e70282e7ebae44db0c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05126e5f483a45c7ace9d19024d5d8c3"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_go_rogue_1_1_coord.html">Coord</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_go_rogue_1_1_coord.html#a05126e5f483a45c7ace9d19024d5d8c3">operator/</a> (<a class="el" href="class_go_rogue_1_1_coord.html">Coord</a> c, int i)</td></tr>
<tr class="memdesc:a05126e5f483a45c7ace9d19024d5d8c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">/ operator. Divides the x-value and y-value of c by i, eg. returns (c.X / i, c.Y / i). Rounds resulting values to the nearest integer.  <a href="#a05126e5f483a45c7ace9d19024d5d8c3">More...</a><br /></td></tr>
<tr class="separator:a05126e5f483a45c7ace9d19024d5d8c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a543f9097b9d72c30371de189b057d65c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_go_rogue_1_1_coord.html">Coord</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_go_rogue_1_1_coord.html#a543f9097b9d72c30371de189b057d65c">operator/</a> (<a class="el" href="class_go_rogue_1_1_coord.html">Coord</a> c, double i)</td></tr>
<tr class="memdesc:a543f9097b9d72c30371de189b057d65c"><td class="mdescLeft">&#160;</td><td class="mdescRight">/ operator. Similar to int version.  <a href="#a543f9097b9d72c30371de189b057d65c">More...</a><br /></td></tr>
<tr class="separator:a543f9097b9d72c30371de189b057d65c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a808584caf9c03f57964f3dc6b9b936f6"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_go_rogue_1_1_coord.html">Coord</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_go_rogue_1_1_coord.html#a808584caf9c03f57964f3dc6b9b936f6">operator+</a> (<a class="el" href="class_go_rogue_1_1_coord.html">Coord</a> c1, <a class="el" href="class_go_rogue_1_1_coord.html">Coord</a> c2)</td></tr>
<tr class="separator:a808584caf9c03f57964f3dc6b9b936f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90a8bfab12c88feddd3c86207547baad"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_go_rogue_1_1_coord.html">Coord</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_go_rogue_1_1_coord.html#a90a8bfab12c88feddd3c86207547baad">operator+</a> (<a class="el" href="class_go_rogue_1_1_coord.html">Coord</a> c, int i)</td></tr>
<tr class="separator:a90a8bfab12c88feddd3c86207547baad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1aed26fa31d742124cd59a7d3f30b44"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_go_rogue_1_1_coord.html">Coord</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_go_rogue_1_1_coord.html#ab1aed26fa31d742124cd59a7d3f30b44">operator+</a> (<a class="el" href="class_go_rogue_1_1_coord.html">Coord</a> c, <a class="el" href="class_go_rogue_1_1_direction.html">Direction</a> d)</td></tr>
<tr class="separator:ab1aed26fa31d742124cd59a7d3f30b44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0751c6d23fb0544ee4d61fe3e47f20cb"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_go_rogue_1_1_coord.html#a0751c6d23fb0544ee4d61fe3e47f20cb">operator==</a> (<a class="el" href="class_go_rogue_1_1_coord.html">Coord</a> c1, <a class="el" href="class_go_rogue_1_1_coord.html">Coord</a> c2)</td></tr>
<tr class="memdesc:a0751c6d23fb0544ee4d61fe3e47f20cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if c1.X == c2.X and c1.Y == c2.Y.  <a href="#a0751c6d23fb0544ee4d61fe3e47f20cb">More...</a><br /></td></tr>
<tr class="separator:a0751c6d23fb0544ee4d61fe3e47f20cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93702b3ce2d8337cd27ffbe5b1564651"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_go_rogue_1_1_coord.html">Coord</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_go_rogue_1_1_coord.html#a93702b3ce2d8337cd27ffbe5b1564651">ToCoord</a> (int index, int rowCount)</td></tr>
<tr class="memdesc:a93702b3ce2d8337cd27ffbe5b1564651"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses the ToIndex function, returning the <a class="el" href="class_go_rogue_1_1_coord.html" title="2d coordinate class. You cannot create instances of this class using a constructor – instead...">Coord</a> represented by a given index.  <a href="#a93702b3ce2d8337cd27ffbe5b1564651">More...</a><br /></td></tr>
<tr class="separator:a93702b3ce2d8337cd27ffbe5b1564651"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97e98e50ebb20ccd0f7f2c82b043cd3d"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_go_rogue_1_1_coord.html#a97e98e50ebb20ccd0f7f2c82b043cd3d">ToIndex</a> (int x, int y, int rowCount)</td></tr>
<tr class="memdesc:a97e98e50ebb20ccd0f7f2c82b043cd3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns y * rowCount + x. Same as <a class="el" href="class_go_rogue_1_1_coord.html#a8cd118940e45c6b28da8765771661096" title="Returns a value that can be used to index this location in a 2D array that is actually encoded in a 1...">Coord.ToIndex(int rowCount)</a>, just takes x and y instead.  <a href="#a97e98e50ebb20ccd0f7f2c82b043cd3d">More...</a><br /></td></tr>
<tr class="separator:a97e98e50ebb20ccd0f7f2c82b043cd3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8f6d221fc4eef936d2d066ea320f673"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_go_rogue_1_1_coord.html#ad8f6d221fc4eef936d2d066ea320f673">ToXValue</a> (int index, int rowCount)</td></tr>
<tr class="memdesc:ad8f6d221fc4eef936d2d066ea320f673"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses the ToIndex function, returning only the X-value for the given index.  <a href="#ad8f6d221fc4eef936d2d066ea320f673">More...</a><br /></td></tr>
<tr class="separator:ad8f6d221fc4eef936d2d066ea320f673"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad317b24acf1245ced9d2bc1e1afef8f"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_go_rogue_1_1_coord.html#aad317b24acf1245ced9d2bc1e1afef8f">ToYValue</a> (int index, int rowCount)</td></tr>
<tr class="memdesc:aad317b24acf1245ced9d2bc1e1afef8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses the ToIndex function, returning only the Y-value for the given index.  <a href="#aad317b24acf1245ced9d2bc1e1afef8f">More...</a><br /></td></tr>
<tr class="separator:aad317b24acf1245ced9d2bc1e1afef8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a8b7a017cfef4c432d60bbb609da7d74e"><td class="memItemLeft" align="right" valign="top">readonly int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_go_rogue_1_1_coord.html#a8b7a017cfef4c432d60bbb609da7d74e">X</a></td></tr>
<tr class="memdesc:a8b7a017cfef4c432d60bbb609da7d74e"><td class="mdescLeft">&#160;</td><td class="mdescRight">X-value of the coordinate.  <a href="#a8b7a017cfef4c432d60bbb609da7d74e">More...</a><br /></td></tr>
<tr class="separator:a8b7a017cfef4c432d60bbb609da7d74e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4d218eaf1e0fc1079a4609e33f29fef"><td class="memItemLeft" align="right" valign="top">readonly int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_go_rogue_1_1_coord.html#ab4d218eaf1e0fc1079a4609e33f29fef">Y</a></td></tr>
<tr class="memdesc:ab4d218eaf1e0fc1079a4609e33f29fef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Y-value of the coordinate.  <a href="#ab4d218eaf1e0fc1079a4609e33f29fef">More...</a><br /></td></tr>
<tr class="separator:ab4d218eaf1e0fc1079a4609e33f29fef"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>2d coordinate class. You cannot create instances of this class using a constructor &ndash; instead, use the Get function to create instances. Also provides numerous static functions to deal with grid/Coord-related math, operations, etc. </p>
<p>If you want the coordinate (1, 2), use Coord.Get(1, 2), and it returns you a <a class="el" href="class_go_rogue_1_1_coord.html" title="2d coordinate class. You cannot create instances of this class using a constructor – instead...">Coord</a> instance. These instances are read-only, however operators such as addition, etc., are provided. This is due to optimizations under the hood. By default, the class keeps a static, internal array that contains an instance of every coordinate between (-3, -3), and (255, 255). If the coordinate x and y values given to Get are within this range, Get returns the appropriate instance from the array. If the coordinates given are outside of the range, it simply returns a new instance. Since most of the coordinates used in roguelike/grid based games will be between (-3, -3) and (255, 255), this can end up drastically reducing the number of memory allocations that need to be done since there will exist one and only one instance of the <a class="el" href="class_go_rogue_1_1_coord.html" title="2d coordinate class. You cannot create instances of this class using a constructor – instead...">Coord</a> class for each value in that range. Since allocations are expensive due to garbage collections, this can significantly improve on efficiency. Later, support may be added for modifying this range as necessary. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="adc18a8b7d151eb1ea243fb815757e1b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc18a8b7d151eb1ea243fb815757e1b9">&sect;&nbsp;</a></span>AllNeighbors() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static IEnumerable&lt;<a class="el" href="class_go_rogue_1_1_coord.html">Coord</a>&gt; GoRogue.Coord.AllNeighbors </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_go_rogue_1_1_coord.html">Coord</a>&#160;</td>
          <td class="paramname"><em>startingLocation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets all 8 neighbors of the given location, cardinals before diagonals. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startingLocation</td><td>Location to return neighbors for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>All 8 neighbors of the given location. </dd></dl>

</div>
</div>
<a id="a24ea92d10a206078748baf2c99891686"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24ea92d10a206078748baf2c99891686">&sect;&nbsp;</a></span>AllNeighbors() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static IEnumerable&lt;<a class="el" href="class_go_rogue_1_1_coord.html">Coord</a>&gt; GoRogue.Coord.AllNeighbors </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>startingX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>startingY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets all 8 neighbors of the given location, cardinals before diagonals. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startingX</td><td>X-coordinate of location to return neighbors for. </td></tr>
    <tr><td class="paramname">startingY</td><td>Y-coordinate of location to return neighbors for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>All 8 neighbors of the given location. </dd></dl>

</div>
</div>
<a id="aaa3008c1315af2d5a8cbdd7949c0370f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa3008c1315af2d5a8cbdd7949c0370f">&sect;&nbsp;</a></span>AllNeighborsClockwise() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static IEnumerable&lt;<a class="el" href="class_go_rogue_1_1_coord.html">Coord</a>&gt; GoRogue.Coord.AllNeighborsClockwise </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_go_rogue_1_1_coord.html">Coord</a>&#160;</td>
          <td class="paramname"><em>startingLocation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_go_rogue_1_1_direction.html">Direction</a>&#160;</td>
          <td class="paramname"><em>startingDirection</em> = <code>null</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets all 8 neighbors of the given location, in clockwise order, starting with the neighbor in the direction given (or UP by default). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startingLocation</td><td>Location to return neighbors for. </td></tr>
    <tr><td class="paramname">startingDirection</td><td><a class="el" href="class_go_rogue_1_1_direction.html" title="Utility class to handle Directions on a grid map. The built-in variables hold the dx and dy for that ...">Direction</a> to start with. Defaults to UP. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>All 8 neighbors of the given location, in clockwise order. </dd></dl>

</div>
</div>
<a id="a93f0ff8ae8581498e441ca7881a66fb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93f0ff8ae8581498e441ca7881a66fb7">&sect;&nbsp;</a></span>AllNeighborsClockwise() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static IEnumerable&lt;<a class="el" href="class_go_rogue_1_1_coord.html">Coord</a>&gt; GoRogue.Coord.AllNeighborsClockwise </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>startingX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>startingY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_go_rogue_1_1_direction.html">Direction</a>&#160;</td>
          <td class="paramname"><em>startingDirection</em> = <code>null</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets all 8 neighbors of the given location, in clockwise order, starting with the neighbor in the direction given (or UP by default). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startingX</td><td>X-coordinate of location to return neighbors for. </td></tr>
    <tr><td class="paramname">startingY</td><td>Y-coordinate of location to return neighbors for. </td></tr>
    <tr><td class="paramname">startingDirection</td><td><a class="el" href="class_go_rogue_1_1_direction.html" title="Utility class to handle Directions on a grid map. The built-in variables hold the dx and dy for that ...">Direction</a> to start with. Defaults to UP. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>All 8 neighbors of the given location, in clockwise order. </dd></dl>

</div>
</div>
<a id="af63ecf35dbd3ed322352e394d13e0315"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af63ecf35dbd3ed322352e394d13e0315">&sect;&nbsp;</a></span>AllNeighborsCounterClockwise() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static IEnumerable&lt;<a class="el" href="class_go_rogue_1_1_coord.html">Coord</a>&gt; GoRogue.Coord.AllNeighborsCounterClockwise </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_go_rogue_1_1_coord.html">Coord</a>&#160;</td>
          <td class="paramname"><em>startingLocation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_go_rogue_1_1_direction.html">Direction</a>&#160;</td>
          <td class="paramname"><em>startingDirection</em> = <code>null</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets all 8 neighbors of the given location, in counter-clockwise order, starting with the neighbor in the direction given (or UP by default). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startingLocation</td><td>Location to return neighbors for. </td></tr>
    <tr><td class="paramname">startingDirection</td><td><a class="el" href="class_go_rogue_1_1_direction.html" title="Utility class to handle Directions on a grid map. The built-in variables hold the dx and dy for that ...">Direction</a> to start with. Defaults to UP. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>All 8 neighbors of the given location, in counter-clockwise order. </dd></dl>

</div>
</div>
<a id="a1e878e0d330818ffc327e893f38289a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e878e0d330818ffc327e893f38289a6">&sect;&nbsp;</a></span>AllNeighborsCounterClockwise() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static IEnumerable&lt;<a class="el" href="class_go_rogue_1_1_coord.html">Coord</a>&gt; GoRogue.Coord.AllNeighborsCounterClockwise </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>startingX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>startingY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_go_rogue_1_1_direction.html">Direction</a>&#160;</td>
          <td class="paramname"><em>startingDirection</em> = <code>null</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets all 8 neighbors of the given location, in counter-clockwise order, starting with the neighbor in the direction given (or UP by default). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startingX</td><td>X-coordinate of location to return neighbors for. </td></tr>
    <tr><td class="paramname">startingY</td><td>Y-coordinate of location to return neighbors for. </td></tr>
    <tr><td class="paramname">startingDirection</td><td><a class="el" href="class_go_rogue_1_1_direction.html" title="Utility class to handle Directions on a grid map. The built-in variables hold the dx and dy for that ...">Direction</a> to start with. Defaults to UP. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>All 8 neighbors of the given location, in counter-clockwise order. </dd></dl>

</div>
</div>
<a id="a33dc72791c581e8231a1637ac9262b62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33dc72791c581e8231a1637ac9262b62">&sect;&nbsp;</a></span>BearingOfLine()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double GoRogue.Coord.BearingOfLine </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_go_rogue_1_1_coord.html">Coord</a>&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_go_rogue_1_1_coord.html">Coord</a>&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates degree bearing of the line (from =&gt; to), where 0 is the direction <a class="el" href="class_go_rogue_1_1_direction.html#a86c2b981e6a3a6f2d13a190b4beec0cc" title="Up direction. ">Direction.UP</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>Coordinate of line starting point. </td></tr>
    <tr><td class="paramname">to</td><td>Coordinate of line ending point. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The degree bearing of the line specified by the two given points. </dd></dl>

</div>
</div>
<a id="acccbce826e899402628d28e73b8f6e56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acccbce826e899402628d28e73b8f6e56">&sect;&nbsp;</a></span>CardinalNeighbors() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static IEnumerable&lt;<a class="el" href="class_go_rogue_1_1_coord.html">Coord</a>&gt; GoRogue.Coord.CardinalNeighbors </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_go_rogue_1_1_coord.html">Coord</a>&#160;</td>
          <td class="paramname"><em>startingLocation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the 4 cardinal neighbors of the given location, in order UP, DOWN, LEFT, RIGHT. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startingLocation</td><td>Location to return neighbors for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The 4 cardinal neighbors of the given location, in order UP, DOWN, LEFT, RIGHT. </dd></dl>

</div>
</div>
<a id="abfcb56f960646057780fbf63cdf997ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfcb56f960646057780fbf63cdf997ff">&sect;&nbsp;</a></span>CardinalNeighbors() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static IEnumerable&lt;<a class="el" href="class_go_rogue_1_1_coord.html">Coord</a>&gt; GoRogue.Coord.CardinalNeighbors </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>startingX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>startingY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the 4 cardinal neighbors of the given location, in order UP, DOWN, LEFT, RIGHT. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startingX</td><td>X-coordinate of location to return neighbors for. </td></tr>
    <tr><td class="paramname">startingY</td><td>Y-coordinate of location to return neighbors for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The 4 cardinal neighbors of the given location, in order UP, DOWN, LEFT, RIGHT. </dd></dl>

</div>
</div>
<a id="aebec8f932d00e6bdcc9e06dc6ccbced8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebec8f932d00e6bdcc9e06dc6ccbced8">&sect;&nbsp;</a></span>CardinalNeighborsClockwise() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static IEnumerable&lt;<a class="el" href="class_go_rogue_1_1_coord.html">Coord</a>&gt; GoRogue.Coord.CardinalNeighborsClockwise </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_go_rogue_1_1_coord.html">Coord</a>&#160;</td>
          <td class="paramname"><em>startingLocation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_go_rogue_1_1_direction.html">Direction</a>&#160;</td>
          <td class="paramname"><em>startingDirection</em> = <code>null</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the 4 cardinal neighbors of the given location, in clockwise order, starting with the neighbor in the direction given (or UP by default). If the direction given is a diagonal, it starts with the closest clockwise cardinal neighbor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startingLocation</td><td>Location to return neighbors for. </td></tr>
    <tr><td class="paramname">startingDirection</td><td><a class="el" href="class_go_rogue_1_1_direction.html" title="Utility class to handle Directions on a grid map. The built-in variables hold the dx and dy for that ...">Direction</a> to start with. Defaults to UP. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The 4 cardinal neighbors of the given location, in clockwise order. </dd></dl>

</div>
</div>
<a id="a36d510d3dfb2d29f760203f01b91be1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36d510d3dfb2d29f760203f01b91be1b">&sect;&nbsp;</a></span>CardinalNeighborsClockwise() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static IEnumerable&lt;<a class="el" href="class_go_rogue_1_1_coord.html">Coord</a>&gt; GoRogue.Coord.CardinalNeighborsClockwise </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>startingX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>startingY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_go_rogue_1_1_direction.html">Direction</a>&#160;</td>
          <td class="paramname"><em>startingDirection</em> = <code>null</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the 4 cardinal neighbors of the given location, in clockwise order, starting with the neighbor in the direction given (or UP by default). If the direction given is a diagonal, it starts with the closest clockwise cardinal neighbor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startingX</td><td>X-coordinate of location to return neighbors for. </td></tr>
    <tr><td class="paramname">startingY</td><td>Y-coordinate of location to return neighbors for. </td></tr>
    <tr><td class="paramname">startingDirection</td><td><a class="el" href="class_go_rogue_1_1_direction.html" title="Utility class to handle Directions on a grid map. The built-in variables hold the dx and dy for that ...">Direction</a> to start with. Defaults to UP. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The 4 cardinal neighbors of the given location, in clockwise order. </dd></dl>

</div>
</div>
<a id="a2087fb4e544a66f6423fbf2ec07e9d98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2087fb4e544a66f6423fbf2ec07e9d98">&sect;&nbsp;</a></span>CardinalNeighborsCounterClockwise() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static IEnumerable&lt;<a class="el" href="class_go_rogue_1_1_coord.html">Coord</a>&gt; GoRogue.Coord.CardinalNeighborsCounterClockwise </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_go_rogue_1_1_coord.html">Coord</a>&#160;</td>
          <td class="paramname"><em>startingLocation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_go_rogue_1_1_direction.html">Direction</a>&#160;</td>
          <td class="paramname"><em>startingDirection</em> = <code>null</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the 4 cardinal neighbors of the given location, in counter-clockwise order, starting with the neighbor in the direction given (or UP by default). If the direction given is a diagonal, it starts with the closest counter-clockwise cardinal neighbor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startingLocation</td><td>Location to return neighbors for. </td></tr>
    <tr><td class="paramname">startingDirection</td><td><a class="el" href="class_go_rogue_1_1_direction.html" title="Utility class to handle Directions on a grid map. The built-in variables hold the dx and dy for that ...">Direction</a> to start with. Defaults to UP. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The 4 cardinal neighbors of the given location, in counter-clockwise order. </dd></dl>

</div>
</div>
<a id="a9b1385d15bf6e9337139f16d23ddd6c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b1385d15bf6e9337139f16d23ddd6c4">&sect;&nbsp;</a></span>CardinalNeighborsCounterClockwise() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static IEnumerable&lt;<a class="el" href="class_go_rogue_1_1_coord.html">Coord</a>&gt; GoRogue.Coord.CardinalNeighborsCounterClockwise </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>startingX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>startingY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_go_rogue_1_1_direction.html">Direction</a>&#160;</td>
          <td class="paramname"><em>startingDirection</em> = <code>null</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the 4 cardinal neighbors of the given location, in counter-clockwise order, starting with the neighbor in the direction given (or UP by default). If the direction given is a diagonal, it starts with the closest counter-clockwise cardinal neighbor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startingX</td><td>X-coordinate of location to return neighbors for. </td></tr>
    <tr><td class="paramname">startingY</td><td>Y-coordinate of location to return neighbors for. </td></tr>
    <tr><td class="paramname">startingDirection</td><td><a class="el" href="class_go_rogue_1_1_direction.html" title="Utility class to handle Directions on a grid map. The built-in variables hold the dx and dy for that ...">Direction</a> to start with. Defaults to UP. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The 4 cardinal neighbors of the given location, in counter-clockwise order. </dd></dl>

</div>
</div>
<a id="a57da954d429fe425077ea6278abe343f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57da954d429fe425077ea6278abe343f">&sect;&nbsp;</a></span>DiagonalNeighbors() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static IEnumerable&lt;<a class="el" href="class_go_rogue_1_1_coord.html">Coord</a>&gt; GoRogue.Coord.DiagonalNeighbors </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_go_rogue_1_1_coord.html">Coord</a>&#160;</td>
          <td class="paramname"><em>startingLocation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the 4 diagonal neighbors of the given location, in order UP_LEFT, UP_RIGHT, DOWN_LEFT, DOWN_RIGHT. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startingLocation</td><td>Location to return neighbors for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The 4 diagonal neighbors of the given location, in order UP_LEFT, UP_RIGHT, DOWN_LEFT, DOWN_RIGHT. </dd></dl>

</div>
</div>
<a id="a0364d75d0b8897f505f87473cb4a1502"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0364d75d0b8897f505f87473cb4a1502">&sect;&nbsp;</a></span>DiagonalNeighbors() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static IEnumerable&lt;<a class="el" href="class_go_rogue_1_1_coord.html">Coord</a>&gt; GoRogue.Coord.DiagonalNeighbors </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>startingX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>startingY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the 4 diagonal neighbors of the given location, in order UP_LEFT, UP_RIGHT, DOWN_LEFT, DOWN_RIGHT. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startingX</td><td>X-coordinate of location to return neighbors for. </td></tr>
    <tr><td class="paramname">startingY</td><td>Y-coordinate of location to return neighbors for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The 4 diagonal neighbors of the given location, in order UP_LEFT, UP_RIGHT, DOWN_LEFT, DOWN_RIGHT. </dd></dl>

</div>
</div>
<a id="a24a54b350e2059752201b95897c7deb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24a54b350e2059752201b95897c7deb6">&sect;&nbsp;</a></span>DiagonalNeighborsClockwise() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static IEnumerable&lt;<a class="el" href="class_go_rogue_1_1_coord.html">Coord</a>&gt; GoRogue.Coord.DiagonalNeighborsClockwise </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_go_rogue_1_1_coord.html">Coord</a>&#160;</td>
          <td class="paramname"><em>startingLocation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_go_rogue_1_1_direction.html">Direction</a>&#160;</td>
          <td class="paramname"><em>startingDirection</em> = <code>null</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the 4 diagonal neighbors of the given location, in clockwise order, starting with the neighbor in the direction given (or UP_RIGHT by default). If the direction given is a cardinal, it starts with the closest clockwise diagonal neighbor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startingLocation</td><td>Location to return neighbors for. </td></tr>
    <tr><td class="paramname">startingDirection</td><td><a class="el" href="class_go_rogue_1_1_direction.html" title="Utility class to handle Directions on a grid map. The built-in variables hold the dx and dy for that ...">Direction</a> to start with. Defaults to UP_RIGHT. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The 4 diagonal neighbors of the given location, in clockwise order. </dd></dl>

</div>
</div>
<a id="a862d1eb729e8c084223e6f985496ca35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a862d1eb729e8c084223e6f985496ca35">&sect;&nbsp;</a></span>DiagonalNeighborsClockwise() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static IEnumerable&lt;<a class="el" href="class_go_rogue_1_1_coord.html">Coord</a>&gt; GoRogue.Coord.DiagonalNeighborsClockwise </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>startingX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>startingY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_go_rogue_1_1_direction.html">Direction</a>&#160;</td>
          <td class="paramname"><em>startingDirection</em> = <code>null</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the 4 diagonal neighbors of the given location, in clockwise order, starting with the neighbor in the direction given (or UP_RIGHT by default). If the direction given is a cardinal, it starts with the closest clockwise diagonal neighbor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startingX</td><td>X-coordinate of location to return neighbors for. </td></tr>
    <tr><td class="paramname">startingY</td><td>Y-coordinate of location to return neighbors for. </td></tr>
    <tr><td class="paramname">startingDirection</td><td><a class="el" href="class_go_rogue_1_1_direction.html" title="Utility class to handle Directions on a grid map. The built-in variables hold the dx and dy for that ...">Direction</a> to start with. Defaults to UP_RIGHT. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The 4 diagonal neighbors of the given location, in clockwise order. </dd></dl>

</div>
</div>
<a id="a6e97444616c3e46c0731971e2cd09365"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e97444616c3e46c0731971e2cd09365">&sect;&nbsp;</a></span>DiagonalNeighborsCounterClockwise() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static IEnumerable&lt;<a class="el" href="class_go_rogue_1_1_coord.html">Coord</a>&gt; GoRogue.Coord.DiagonalNeighborsCounterClockwise </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_go_rogue_1_1_coord.html">Coord</a>&#160;</td>
          <td class="paramname"><em>startingLocation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_go_rogue_1_1_direction.html">Direction</a>&#160;</td>
          <td class="paramname"><em>startingDirection</em> = <code>null</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the 4 diagonal neighbors of the given location, in counter-clockwise order, starting with the neighbor in the direction given (or UP_LEFT by default). If the direction given is a cardinal, it starts with the closest counter-clockwise diagonal neighbor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startingLocation</td><td>Location to return neighbors for. </td></tr>
    <tr><td class="paramname">startingDirection</td><td><a class="el" href="class_go_rogue_1_1_direction.html" title="Utility class to handle Directions on a grid map. The built-in variables hold the dx and dy for that ...">Direction</a> to start with. Defaults to UP_LEFT. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The 4 diagonal neighbors of the given location, in counter-clockwise order. </dd></dl>

</div>
</div>
<a id="a5c0b5c1c7a5097f34ed580202b589736"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c0b5c1c7a5097f34ed580202b589736">&sect;&nbsp;</a></span>DiagonalNeighborsCounterClockwise() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static IEnumerable&lt;<a class="el" href="class_go_rogue_1_1_coord.html">Coord</a>&gt; GoRogue.Coord.DiagonalNeighborsCounterClockwise </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>startingX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>startingY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_go_rogue_1_1_direction.html">Direction</a>&#160;</td>
          <td class="paramname"><em>startingDirection</em> = <code>null</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the 4 diagonal neighbors of the given location, in counter-clockwise order, starting with the neighbor in the direction given (or UP_LEFT by default). If the direction given is a cardinal, it starts with the closest counter-clockwise diagonal neighbor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startingX</td><td>X-coordinate of location to return neighbors for. </td></tr>
    <tr><td class="paramname">startingY</td><td>Y-coordinate of location to return neighbors for. </td></tr>
    <tr><td class="paramname">startingDirection</td><td><a class="el" href="class_go_rogue_1_1_direction.html" title="Utility class to handle Directions on a grid map. The built-in variables hold the dx and dy for that ...">Direction</a> to start with. Defaults to UP_LEFT. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The 4 diagonal neighbors of the given location, in counter-clockwise order. </dd></dl>

</div>
</div>
<a id="aee8eebff28c6d73c89629909c0d0aec8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee8eebff28c6d73c89629909c0d0aec8">&sect;&nbsp;</a></span>Equals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">override bool GoRogue.Coord.Equals </td>
          <td>(</td>
          <td class="paramtype">object&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as operator == in this case; returns false if obj is not a <a class="el" href="class_go_rogue_1_1_coord.html" title="2d coordinate class. You cannot create instances of this class using a constructor – instead...">Coord</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The object to compare the current <a class="el" href="class_go_rogue_1_1_coord.html" title="2d coordinate class. You cannot create instances of this class using a constructor – instead...">Coord</a> to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if o is a <a class="el" href="class_go_rogue_1_1_coord.html" title="2d coordinate class. You cannot create instances of this class using a constructor – instead...">Coord</a> instance, and the two coordinates are equal, false otherwise. </dd></dl>

</div>
</div>
<a id="a1ecee2b7034831c1d701bf40b7af3764"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ecee2b7034831c1d701bf40b7af3764">&sect;&nbsp;</a></span>EuclideanDistanceMagnitude()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double GoRogue.Coord.EuclideanDistanceMagnitude </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_go_rogue_1_1_coord.html">Coord</a>&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_go_rogue_1_1_coord.html">Coord</a>&#160;</td>
          <td class="paramname"><em>c2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the result of the euclidean distance formula, without the square root &ndash; eg., (c2.X - c1.X) * (c2.X - c1.X) + (c2.Y - c1.Y) * (c2.Y - c1.Y). Use this if you only care about the magnitude of the distance &ndash; eg., if you're trying to compare two distances. Omitting the square root provides a speed increase. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c1</td><td>The first point. </td></tr>
    <tr><td class="paramname">c2</td><td>The second point. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The "magnitude" of the euclidean distance between the two points &ndash; basically the distance formula without the square root. </dd></dl>

</div>
</div>
<a id="ae25bcfd7c2943acb6de3431c6c33a423"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae25bcfd7c2943acb6de3431c6c33a423">&sect;&nbsp;</a></span>Get()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_go_rogue_1_1_coord.html">Coord</a> GoRogue.Coord.Get </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the proper <a class="el" href="class_go_rogue_1_1_coord.html" title="2d coordinate class. You cannot create instances of this class using a constructor – instead...">Coord</a> instance for the given x and y values. Will return the one in the array if the values are in the appropriate range, otherwise will create a new one and return that one. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The x-value for the coordinate. </td></tr>
    <tr><td class="paramname">y</td><td>The y-value for the coordinate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="class_go_rogue_1_1_coord.html" title="2d coordinate class. You cannot create instances of this class using a constructor – instead...">Coord</a> representing the given x-value and y-value. </dd></dl>

</div>
</div>
<a id="acc0cb4f91fb9942e4ecb7216a56ed240"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc0cb4f91fb9942e4ecb7216a56ed240">&sect;&nbsp;</a></span>GetHashCode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">override int GoRogue.Coord.GetHashCode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a hash code for the <a class="el" href="class_go_rogue_1_1_coord.html" title="2d coordinate class. You cannot create instances of this class using a constructor – instead...">Coord</a>. The important parts: it should be fairly fast and it does not collide often. The details: it uses a seperate bit-mixing algorithm for X and Y, with X and Y each multiplied by a differet large integer, then xors the mixed values, and does a right shift, then multiplies by an overflowing prime number. </p>
<dl class="section return"><dt>Returns</dt><dd>The hash-code for the <a class="el" href="class_go_rogue_1_1_coord.html" title="2d coordinate class. You cannot create instances of this class using a constructor – instead...">Coord</a>. </dd></dl>

</div>
</div>
<a id="ae2c2d73d6057f120ecd3628428cdea45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2c2d73d6057f120ecd3628428cdea45">&sect;&nbsp;</a></span>Midpoint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_go_rogue_1_1_coord.html">Coord</a> GoRogue.Coord.Midpoint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_go_rogue_1_1_coord.html">Coord</a>&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_go_rogue_1_1_coord.html">Coord</a>&#160;</td>
          <td class="paramname"><em>c2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the midpoint between the two points. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c1</td><td>The first point. </td></tr>
    <tr><td class="paramname">c2</td><td>The second point. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The midpoint between c1 and c2 </dd></dl>

</div>
</div>
<a id="ad81e63c68df26f28d73fd907a9b58338"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad81e63c68df26f28d73fd907a9b58338">&sect;&nbsp;</a></span>Neighbors() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static IEnumerable&lt;<a class="el" href="class_go_rogue_1_1_coord.html">Coord</a>&gt; GoRogue.Coord.Neighbors </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_go_rogue_1_1_coord.html">Coord</a>&#160;</td>
          <td class="paramname"><em>startingLocation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_go_rogue_1_1_distance.html">Distance</a>&#160;</td>
          <td class="paramname"><em>distanceCalc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets all neighbors of the specified location, based on the distance calculation specified (MANHATTAN yields 4 neighbors, others yield 8, with cardinals returned before diagonals). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startingLocation</td><td>Location to return neighbors for. </td></tr>
    <tr><td class="paramname">distanceCalc</td><td><a class="el" href="class_go_rogue_1_1_distance.html" title="Class representing a method of calculating distance. You cannot create instances of this class using ...">Distance</a> calculation used to determine which tiles are consdered adjacent. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>All neighbors of the given location, according to the distance calculation specified. </dd></dl>

</div>
</div>
<a id="a9068eeda71406bfc7bfdd8ae4bed4525"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9068eeda71406bfc7bfdd8ae4bed4525">&sect;&nbsp;</a></span>Neighbors() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static IEnumerable&lt;<a class="el" href="class_go_rogue_1_1_coord.html">Coord</a>&gt; GoRogue.Coord.Neighbors </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>startingX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>startingY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_go_rogue_1_1_distance.html">Distance</a>&#160;</td>
          <td class="paramname"><em>distanceCalc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets all neighbors of the specified location, based on the distance calculation specified (MANHATTAN yields 4 neighbors, others yield 8, with cardinals returned before diagonals). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startingX</td><td>X-coordinate of location to return neighbors for. </td></tr>
    <tr><td class="paramname">startingY</td><td>Y-coordinate of location to return neighbors for. </td></tr>
    <tr><td class="paramname">distanceCalc</td><td><a class="el" href="class_go_rogue_1_1_distance.html" title="Class representing a method of calculating distance. You cannot create instances of this class using ...">Distance</a> calculation used to determine which tiles are consdered adjacent. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>All neighbors of the given location, according to the distance calculation specified. </dd></dl>

</div>
</div>
<a id="a1e4d84d3ccbade2c89ec9413d9223b64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e4d84d3ccbade2c89ec9413d9223b64">&sect;&nbsp;</a></span>Neighbors() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static IEnumerable&lt;<a class="el" href="class_go_rogue_1_1_coord.html">Coord</a>&gt; GoRogue.Coord.Neighbors </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_go_rogue_1_1_coord.html">Coord</a>&#160;</td>
          <td class="paramname"><em>startingLocation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_go_rogue_1_1_radius.html">Radius</a>&#160;</td>
          <td class="paramname"><em>shape</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets all neighbors of the specified location, based on the radius shape specified (DIAMOND/OCTAHEDRON yields 4 neighbors, others yield 8, with cardinals returned before diagonals). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startingLocation</td><td>Location to return neighbors for. </td></tr>
    <tr><td class="paramname">shape</td><td><a class="el" href="class_go_rogue_1_1_radius.html" title="Class representing different radius types. Similar in architecture to Coord in architecture – it can...">Radius</a> shape used to determine which tiles are consdered adjacent. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>All neighbors of the given location, according to the radius shape specified. </dd></dl>

</div>
</div>
<a id="aa8d2f81643b97d137e517fc424dc5023"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8d2f81643b97d137e517fc424dc5023">&sect;&nbsp;</a></span>Neighbors() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static IEnumerable&lt;<a class="el" href="class_go_rogue_1_1_coord.html">Coord</a>&gt; GoRogue.Coord.Neighbors </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>startingX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>startingY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_go_rogue_1_1_radius.html">Radius</a>&#160;</td>
          <td class="paramname"><em>shape</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets all neighbors of the specified location, based on the radius shape specified (DIAMOND/OCTAHEDRON yields 4 neighbors, others yield 8, with cardinals returned before diagonals). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startingX</td><td>X-coordinate of location to return neighbors for. </td></tr>
    <tr><td class="paramname">startingY</td><td>Y-coordinate of location to return neighbors for. </td></tr>
    <tr><td class="paramname">shape</td><td><a class="el" href="class_go_rogue_1_1_radius.html" title="Class representing different radius types. Similar in architecture to Coord in architecture – it can...">Radius</a> shape used to determine which tiles are consdered adjacent. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>All neighbors of the given location, according to the radius shape specified. </dd></dl>

</div>
</div>
<a id="a91f47d9c4a3b355a5786c137a5c490ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91f47d9c4a3b355a5786c137a5c490ce">&sect;&nbsp;</a></span>NeighborsClockwise() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static IEnumerable&lt;<a class="el" href="class_go_rogue_1_1_coord.html">Coord</a>&gt; GoRogue.Coord.NeighborsClockwise </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_go_rogue_1_1_coord.html">Coord</a>&#160;</td>
          <td class="paramname"><em>startingLocation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_go_rogue_1_1_distance.html">Distance</a>&#160;</td>
          <td class="paramname"><em>distanceCalc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_go_rogue_1_1_direction.html">Direction</a>&#160;</td>
          <td class="paramname"><em>startingDirection</em> = <code>null</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets all neighbors of the specified location, in clockwise order, based on the distance calculation specified (MANHATTAN yields 4 neighbors, others yield 8). The first direction returned is the one specified as startingDirection, or the closest clockwise cardinal if it is a diagonal and MANHATTAN is used. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startingLocation</td><td>Location to return neighbors for. </td></tr>
    <tr><td class="paramname">distanceCalc</td><td><a class="el" href="class_go_rogue_1_1_distance.html" title="Class representing a method of calculating distance. You cannot create instances of this class using ...">Distance</a> calculation used to determine which tiles are consdered adjacent. </td></tr>
    <tr><td class="paramname">startingDirection</td><td>The direction to start with. Defaults to UP. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>All neighbors of the given location, according to the distance calculation specified. </dd></dl>

</div>
</div>
<a id="a87ce525c63d524f75212884a1e5da8be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87ce525c63d524f75212884a1e5da8be">&sect;&nbsp;</a></span>NeighborsClockwise() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static IEnumerable&lt;<a class="el" href="class_go_rogue_1_1_coord.html">Coord</a>&gt; GoRogue.Coord.NeighborsClockwise </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>startingX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>startingY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_go_rogue_1_1_distance.html">Distance</a>&#160;</td>
          <td class="paramname"><em>distanceCalc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_go_rogue_1_1_direction.html">Direction</a>&#160;</td>
          <td class="paramname"><em>startingDirection</em> = <code>null</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets all neighbors of the specified location, in clockwise order, based on the distance calculation specified (MANHATTAN yields 4 neighbors, others yield 8). The first direction returned is the one specified as startingDirection, or the closest clockwise cardinal if it is a diagonal and MANHATTAN is used. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startingX</td><td>X-coordinate of location to return neighbors for. </td></tr>
    <tr><td class="paramname">startingY</td><td>Y-coordinate of location to return neighbors for. </td></tr>
    <tr><td class="paramname">distanceCalc</td><td><a class="el" href="class_go_rogue_1_1_distance.html" title="Class representing a method of calculating distance. You cannot create instances of this class using ...">Distance</a> calculation used to determine which tiles are consdered adjacent. </td></tr>
    <tr><td class="paramname">startingDirection</td><td>The direction to start with. Defaults to UP. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>All neighbors of the given location, according to the distance calculation specified. </dd></dl>

</div>
</div>
<a id="a1b28efc6644df5b8a994726e8000653b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b28efc6644df5b8a994726e8000653b">&sect;&nbsp;</a></span>NeighborsClockwise() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static IEnumerable&lt;<a class="el" href="class_go_rogue_1_1_coord.html">Coord</a>&gt; GoRogue.Coord.NeighborsClockwise </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_go_rogue_1_1_coord.html">Coord</a>&#160;</td>
          <td class="paramname"><em>startingLocation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_go_rogue_1_1_radius.html">Radius</a>&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_go_rogue_1_1_direction.html">Direction</a>&#160;</td>
          <td class="paramname"><em>startingDirection</em> = <code>null</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets all neighbors of the specified location, in clockwise order, based on the radius shape specified (DIAMOND/OCTAHEDRON yields 4 neighbors, others yield 8). The first direction returned is the one specified as startingDirection, or the closest clockwise cardinal if it is a diagonal and DIAMOND/OCTAHEDRON is used. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startingLocation</td><td>Location to return neighbors for. </td></tr>
    <tr><td class="paramname">shape</td><td><a class="el" href="class_go_rogue_1_1_radius.html" title="Class representing different radius types. Similar in architecture to Coord in architecture – it can...">Radius</a> shape used to determine which tiles are consdered adjacent. </td></tr>
    <tr><td class="paramname">startingDirection</td><td>The direction to start with. Defaults to UP. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>All neighbors of the given location, according to the distance calculation specified. </dd></dl>

</div>
</div>
<a id="ac0d6bcab1a0e8cdcdcb215a0083b743c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0d6bcab1a0e8cdcdcb215a0083b743c">&sect;&nbsp;</a></span>NeighborsClockwise() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static IEnumerable&lt;<a class="el" href="class_go_rogue_1_1_coord.html">Coord</a>&gt; GoRogue.Coord.NeighborsClockwise </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>startingX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>startingY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_go_rogue_1_1_radius.html">Radius</a>&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_go_rogue_1_1_direction.html">Direction</a>&#160;</td>
          <td class="paramname"><em>startingDirection</em> = <code>null</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets all neighbors of the specified location, in clockwise order, based on the radius shape specified (DIAMOND/OCTAHEDRON yields 4 neighbors, others yield 8). The first direction returned is the one specified as startingDirection, or the closest clockwise cardinal if it is a diagonal and DIAMOND/OCTAHEDRON is used. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startingX</td><td>X-coordinate of location to return neighbors for. </td></tr>
    <tr><td class="paramname">startingY</td><td>Y-coordinate of location to return neighbors for. </td></tr>
    <tr><td class="paramname">shape</td><td><a class="el" href="class_go_rogue_1_1_radius.html" title="Class representing different radius types. Similar in architecture to Coord in architecture – it can...">Radius</a> shape used to determine which tiles are consdered adjacent. </td></tr>
    <tr><td class="paramname">startingDirection</td><td>The direction to start with. Defaults to UP. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>All neighbors of the given location, according to the distance calculation specified. </dd></dl>

</div>
</div>
<a id="a2b6383d28729f1e19a300046627f44b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b6383d28729f1e19a300046627f44b0">&sect;&nbsp;</a></span>NeighborsCounterClockwise() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static IEnumerable&lt;<a class="el" href="class_go_rogue_1_1_coord.html">Coord</a>&gt; GoRogue.Coord.NeighborsCounterClockwise </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_go_rogue_1_1_coord.html">Coord</a>&#160;</td>
          <td class="paramname"><em>startingLocation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_go_rogue_1_1_distance.html">Distance</a>&#160;</td>
          <td class="paramname"><em>distanceCalc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_go_rogue_1_1_direction.html">Direction</a>&#160;</td>
          <td class="paramname"><em>startingDirection</em> = <code>null</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets all neighbors of the specified location, in counter-clockwise order, based on the distance calculation specified (MANHATTAN yields 4 neighbors, others yield 8). The first direction returned is the one specified as startingDirection, or the closest counter-clockwise cardinal if it is a diagonal and MANHATTAN is used. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startingLocation</td><td>Location to return neighbors for. </td></tr>
    <tr><td class="paramname">distanceCalc</td><td><a class="el" href="class_go_rogue_1_1_distance.html" title="Class representing a method of calculating distance. You cannot create instances of this class using ...">Distance</a> calculation used to determine which tiles are consdered adjacent. </td></tr>
    <tr><td class="paramname">startingDirection</td><td>The direction to start with. Defaults to UP. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>All neighbors of the given location, according to the distance calculation specified. </dd></dl>

</div>
</div>
<a id="a55407cf6cb7a3226d076b5ce642afac1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55407cf6cb7a3226d076b5ce642afac1">&sect;&nbsp;</a></span>NeighborsCounterClockwise() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static IEnumerable&lt;<a class="el" href="class_go_rogue_1_1_coord.html">Coord</a>&gt; GoRogue.Coord.NeighborsCounterClockwise </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>startingX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>startingY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_go_rogue_1_1_distance.html">Distance</a>&#160;</td>
          <td class="paramname"><em>distanceCalc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_go_rogue_1_1_direction.html">Direction</a>&#160;</td>
          <td class="paramname"><em>startingDirection</em> = <code>null</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets all neighbors of the specified location, in counter-clockwise order, based on the distance calculation specified (MANHATTAN yields 4 neighbors, others yield 8). The first direction returned is the one specified as startingDirection, or the closest counter-clockwise cardinal if it is a diagonal and MANHATTAN is used. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startingX</td><td>X-coordinate of location to return neighbors for. </td></tr>
    <tr><td class="paramname">startingY</td><td>Y-coordinate of location to return neighbors for. </td></tr>
    <tr><td class="paramname">distanceCalc</td><td><a class="el" href="class_go_rogue_1_1_distance.html" title="Class representing a method of calculating distance. You cannot create instances of this class using ...">Distance</a> calculation used to determine which tiles are consdered adjacent. </td></tr>
    <tr><td class="paramname">startingDirection</td><td>The direction to start with. Defaults to UP. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>All neighbors of the given location, according to the distance calculation specified. </dd></dl>

</div>
</div>
<a id="ae3d5c076db6efebe3f1def8640ce316e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3d5c076db6efebe3f1def8640ce316e">&sect;&nbsp;</a></span>NeighborsCounterClockwise() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static IEnumerable&lt;<a class="el" href="class_go_rogue_1_1_coord.html">Coord</a>&gt; GoRogue.Coord.NeighborsCounterClockwise </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_go_rogue_1_1_coord.html">Coord</a>&#160;</td>
          <td class="paramname"><em>startingLocation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_go_rogue_1_1_radius.html">Radius</a>&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_go_rogue_1_1_direction.html">Direction</a>&#160;</td>
          <td class="paramname"><em>startingDirection</em> = <code>null</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets all neighbors of the specified location, in counter-clockwise order, based on the radius shape specified (DIAMOND/OCTAHEDRON yields 4 neighbors, others yield 8). The first direction returned is the one specified as startingDirection, or the closest counter-clockwise cardinal if it is a diagonal and DIAMOND/OCTAHEDRON is used. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startingLocation</td><td>Location to return neighbors for. </td></tr>
    <tr><td class="paramname">shape</td><td><a class="el" href="class_go_rogue_1_1_radius.html" title="Class representing different radius types. Similar in architecture to Coord in architecture – it can...">Radius</a> shape used to determine which tiles are consdered adjacent. </td></tr>
    <tr><td class="paramname">startingDirection</td><td>The direction to start with. Defaults to UP. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>All neighbors of the given location, according to the distance calculation specified. </dd></dl>

</div>
</div>
<a id="ab0875304dcc50a35dbb4c3d8fe9e01b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0875304dcc50a35dbb4c3d8fe9e01b4">&sect;&nbsp;</a></span>NeighborsCounterClockwise() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static IEnumerable&lt;<a class="el" href="class_go_rogue_1_1_coord.html">Coord</a>&gt; GoRogue.Coord.NeighborsCounterClockwise </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>startingX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>startingY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_go_rogue_1_1_radius.html">Radius</a>&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_go_rogue_1_1_direction.html">Direction</a>&#160;</td>
          <td class="paramname"><em>startingDirection</em> = <code>null</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets all neighbors of the specified location, in counter-clockwise order, based on the radius shape specified (DIAMOND/OCTAHEDRON yields 4 neighbors, others yield 8). The first direction returned is the one specified as startingDirection, or the closest counter-clockwise cardinal if it is a diagonal and DIAMOND/OCTAHEDRON is used. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startingX</td><td>X-coordinate of location to return neighbors for. </td></tr>
    <tr><td class="paramname">startingY</td><td>Y-coordinate of location to return neighbors for. </td></tr>
    <tr><td class="paramname">shape</td><td><a class="el" href="class_go_rogue_1_1_radius.html" title="Class representing different radius types. Similar in architecture to Coord in architecture – it can...">Radius</a> shape used to determine which tiles are consdered adjacent. </td></tr>
    <tr><td class="paramname">startingDirection</td><td>The direction to start with. Defaults to UP. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>All neighbors of the given location, according to the distance calculation specified. </dd></dl>

</div>
</div>
<a id="a1965e10afb1c163c932945c8bbfca8c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1965e10afb1c163c932945c8bbfca8c1">&sect;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool GoRogue.Coord.operator!= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_go_rogue_1_1_coord.html">Coord</a>&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_go_rogue_1_1_coord.html">Coord</a>&#160;</td>
          <td class="paramname"><em>c2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>True if either the x-values or y-values are not equal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c1</td><td>First coordinate to compare. </td></tr>
    <tr><td class="paramname">c2</td><td>Second coordinate to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if either the x-values or y-values are not equal, false if they are both equal. </dd></dl>

</div>
</div>
<a id="a4f5605039303c71b3ee33b10223a8173"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f5605039303c71b3ee33b10223a8173">&sect;&nbsp;</a></span>operator*() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_go_rogue_1_1_coord.html">Coord</a> GoRogue.Coord.operator* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_go_rogue_1_1_coord.html">Coord</a>&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<ul>
<li>operator. Multiplies the x-value and y-value of c by i, eg. returns (c.X * i, c.Y * i) </li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Coordinate to multiply by the scalar. </td></tr>
    <tr><td class="paramname">i</td><td>Scalar to multiply the coordinate by. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Coordinate (c.X * i, c.Y * i) </dd></dl>

</div>
</div>
<a id="ab96c645fe4ae9e70282e7ebae44db0c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab96c645fe4ae9e70282e7ebae44db0c0">&sect;&nbsp;</a></span>operator*() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_go_rogue_1_1_coord.html">Coord</a> GoRogue.Coord.operator* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_go_rogue_1_1_coord.html">Coord</a>&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<ul>
<li>operator, similar to the int version. Rounds x-value and y-value to the nearest integer. Effectively "scale c by i". </li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>The coordinate to multiply by the scalar. </td></tr>
    <tr><td class="paramname">i</td><td>The scalar to multiply the coordinate by. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Coordinate (c.X * i, c.Y * i), with the resulting values rounded to nearest integer. </dd></dl>

</div>
</div>
<a id="a808584caf9c03f57964f3dc6b9b936f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a808584caf9c03f57964f3dc6b9b936f6">&sect;&nbsp;</a></span>operator+() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_go_rogue_1_1_coord.html">Coord</a> GoRogue.Coord.operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_go_rogue_1_1_coord.html">Coord</a>&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_go_rogue_1_1_coord.html">Coord</a>&#160;</td>
          <td class="paramname"><em>c2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<ul>
<li>operator. Returns the coordinate (c1.X + c2.X, c1.Y + c2.Y). </li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c1</td><td>The first coordinate. </td></tr>
    <tr><td class="paramname">c2</td><td>The coordinate to add to c1. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>c1 + c2, eg. (c1.X + c2.X, c1.Y + c2.Y) </dd></dl>

</div>
</div>
<a id="a90a8bfab12c88feddd3c86207547baad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90a8bfab12c88feddd3c86207547baad">&sect;&nbsp;</a></span>operator+() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_go_rogue_1_1_coord.html">Coord</a> GoRogue.Coord.operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_go_rogue_1_1_coord.html">Coord</a>&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<ul>
<li>operator. Adds scalar i to the x and y values of c; eg., returns (c.X + i, c.Y + i). </li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Coordinate to add scalar to. </td></tr>
    <tr><td class="paramname">i</td><td>Scalar to add to coordinate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Coordinate resulting from adding scalar i to x-value and y-value of c1. </dd></dl>

</div>
</div>
<a id="ab1aed26fa31d742124cd59a7d3f30b44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1aed26fa31d742124cd59a7d3f30b44">&sect;&nbsp;</a></span>operator+() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_go_rogue_1_1_coord.html">Coord</a> GoRogue.Coord.operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_go_rogue_1_1_coord.html">Coord</a>&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_go_rogue_1_1_direction.html">Direction</a>&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<ul>
<li>operator. Translates the given coordinate by the given direction, eg. returns (c.X + d.DeltaX, c.Y + d.DeltaY). </li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>The coordinate to translate by the given direction. </td></tr>
    <tr><td class="paramname">d</td><td>The direction to translate the coordinate by. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The coordinate translated by the given direction, eg. (c.X + d.DeltaX, c.Y + d.DeltaY </dd></dl>

</div>
</div>
<a id="a3b9654ccdac1e2b628b5aeae8f574455"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b9654ccdac1e2b628b5aeae8f574455">&sect;&nbsp;</a></span>operator-() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_go_rogue_1_1_coord.html">Coord</a> GoRogue.Coord.operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_go_rogue_1_1_coord.html">Coord</a>&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_go_rogue_1_1_coord.html">Coord</a>&#160;</td>
          <td class="paramname"><em>c2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<ul>
<li>operator. Returns the coordinate (c1.X - c2.X, c1.Y - c2.Y) </li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c1</td><td>The first coordinate. </td></tr>
    <tr><td class="paramname">c2</td><td>The coordinate to subtract from c1. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>c1 - c2, eg. (c1.X - c2.X, c1.Y - c2.Y) </dd></dl>

</div>
</div>
<a id="ab049f69b3505dc4b1328fcb489cb51c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab049f69b3505dc4b1328fcb489cb51c9">&sect;&nbsp;</a></span>operator-() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_go_rogue_1_1_coord.html">Coord</a> GoRogue.Coord.operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_go_rogue_1_1_coord.html">Coord</a>&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<ul>
<li>operator. Subtracts scalar i from the x and y values of c1, eg. returns (c.X - i, c.Y - i). </li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Coordinate to subtract the scalar from. </td></tr>
    <tr><td class="paramname">i</td><td>Scalar to subtract from the coordinate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a05126e5f483a45c7ace9d19024d5d8c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05126e5f483a45c7ace9d19024d5d8c3">&sect;&nbsp;</a></span>operator/() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_go_rogue_1_1_coord.html">Coord</a> GoRogue.Coord.operator/ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_go_rogue_1_1_coord.html">Coord</a>&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>/ operator. Divides the x-value and y-value of c by i, eg. returns (c.X / i, c.Y / i). Rounds resulting values to the nearest integer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>The coordinate to divide by scalar. </td></tr>
    <tr><td class="paramname">i</td><td>The scalar to divide the coordinate by. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(c.X / i, c.Y / i), with the resulting values rounded to the nearest integer. </dd></dl>

</div>
</div>
<a id="a543f9097b9d72c30371de189b057d65c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a543f9097b9d72c30371de189b057d65c">&sect;&nbsp;</a></span>operator/() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_go_rogue_1_1_coord.html">Coord</a> GoRogue.Coord.operator/ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_go_rogue_1_1_coord.html">Coord</a>&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>/ operator. Similar to int version. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>The coordinate to divide by scalar. </td></tr>
    <tr><td class="paramname">i</td><td>The scalar to divide the coordinate by. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(c.X / i, c.Y / i), with the resulting values rounded to the nearest integer. </dd></dl>

</div>
</div>
<a id="a0751c6d23fb0544ee4d61fe3e47f20cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0751c6d23fb0544ee4d61fe3e47f20cb">&sect;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool GoRogue.Coord.operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_go_rogue_1_1_coord.html">Coord</a>&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_go_rogue_1_1_coord.html">Coord</a>&#160;</td>
          <td class="paramname"><em>c2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>True if c1.X == c2.X and c1.Y == c2.Y. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c1</td><td>First coodinate to compare. </td></tr>
    <tr><td class="paramname">c2</td><td>Second coordinate to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the two coordinates are equal, false if not. </dd></dl>

</div>
</div>
<a id="a93702b3ce2d8337cd27ffbe5b1564651"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93702b3ce2d8337cd27ffbe5b1564651">&sect;&nbsp;</a></span>ToCoord()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_go_rogue_1_1_coord.html">Coord</a> GoRogue.Coord.ToCoord </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rowCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reverses the ToIndex function, returning the <a class="el" href="class_go_rogue_1_1_coord.html" title="2d coordinate class. You cannot create instances of this class using a constructor – instead...">Coord</a> represented by a given index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index in 1D form. </td></tr>
    <tr><td class="paramname">rowCount</td><td>The number of rows. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="class_go_rogue_1_1_coord.html" title="2d coordinate class. You cannot create instances of this class using a constructor – instead...">Coord</a> represented by the 1D index given. </dd></dl>

</div>
</div>
<a id="a97e98e50ebb20ccd0f7f2c82b043cd3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97e98e50ebb20ccd0f7f2c82b043cd3d">&sect;&nbsp;</a></span>ToIndex() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int GoRogue.Coord.ToIndex </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rowCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns y * rowCount + x. Same as <a class="el" href="class_go_rogue_1_1_coord.html#a8cd118940e45c6b28da8765771661096" title="Returns a value that can be used to index this location in a 2D array that is actually encoded in a 1...">Coord.ToIndex(int rowCount)</a>, just takes x and y instead. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>X-value of the coordinate. </td></tr>
    <tr><td class="paramname">y</td><td>Y-value of the coordinate. </td></tr>
    <tr><td class="paramname">rowCount</td><td>The number of rows, used to do math to calculate index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The 1D index of this <a class="el" href="class_go_rogue_1_1_coord.html" title="2d coordinate class. You cannot create instances of this class using a constructor – instead...">Coord</a>. </dd></dl>

</div>
</div>
<a id="a8cd118940e45c6b28da8765771661096"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cd118940e45c6b28da8765771661096">&sect;&nbsp;</a></span>ToIndex() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GoRogue.Coord.ToIndex </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rowCount</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a value that can be used to index this location in a 2D array that is actually encoded in a 1D array. Actual value is Y * rowCount + X. The 2D array being represented should have [width, height] of [rowCount, dontCare] for this index to be valid. Note that, when this method is used, if one needs to use a nested for loop to iterate over this array, it is best to do for y... as the outer loop and for x..., as the inner loop, for cache performance reasons. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rowCount</td><td>The number of rows, used to do math to calculate index. Usually the width of the 2D array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The 1D index of this <a class="el" href="class_go_rogue_1_1_coord.html" title="2d coordinate class. You cannot create instances of this class using a constructor – instead...">Coord</a>. </dd></dl>

</div>
</div>
<a id="abdf9814ccd98c262780beaf4d5774aa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdf9814ccd98c262780beaf4d5774aa5">&sect;&nbsp;</a></span>ToString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">override string GoRogue.Coord.ToString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns representation (X, Y). </p>
<dl class="section return"><dt>Returns</dt><dd>String (X, Y) </dd></dl>

</div>
</div>
<a id="ad8f6d221fc4eef936d2d066ea320f673"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8f6d221fc4eef936d2d066ea320f673">&sect;&nbsp;</a></span>ToXValue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int GoRogue.Coord.ToXValue </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rowCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reverses the ToIndex function, returning only the X-value for the given index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index in 1D form. </td></tr>
    <tr><td class="paramname">rowCount</td><td>The number of rows. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The X-value for the location represented by the given index. </dd></dl>

</div>
</div>
<a id="aad317b24acf1245ced9d2bc1e1afef8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad317b24acf1245ced9d2bc1e1afef8f">&sect;&nbsp;</a></span>ToYValue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int GoRogue.Coord.ToYValue </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rowCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reverses the ToIndex function, returning only the Y-value for the given index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index in 1D form. </td></tr>
    <tr><td class="paramname">rowCount</td><td>The number of rows. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Y-value for the location represented by the given index. </dd></dl>

</div>
</div>
<a id="ad678b722d6d7c673cfd1525ab1aa3adb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad678b722d6d7c673cfd1525ab1aa3adb">&sect;&nbsp;</a></span>Translate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_go_rogue_1_1_coord.html">Coord</a> GoRogue.Coord.Translate </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the coordinate resulting from adding dx to the X-value of the coordinate, and dy to the Y-value of the coordinate, eg. (X + dx, Y + dy). Provided for convenience. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dx</td><td>Delta x to add to coordinate. </td></tr>
    <tr><td class="paramname">dy</td><td>Delta y to add to coordinate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The coordinate (X + dx, Y + dy) </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a8b7a017cfef4c432d60bbb609da7d74e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b7a017cfef4c432d60bbb609da7d74e">&sect;&nbsp;</a></span>X</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">readonly int GoRogue.Coord.X</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>X-value of the coordinate. </p>

</div>
</div>
<a id="ab4d218eaf1e0fc1079a4609e33f29fef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4d218eaf1e0fc1079a4609e33f29fef">&sect;&nbsp;</a></span>Y</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">readonly int GoRogue.Coord.Y</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Y-value of the coordinate. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>GoRogue/Coord.cs</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.12
</small></address>
</body>
</html>
