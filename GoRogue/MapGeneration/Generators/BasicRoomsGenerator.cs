using GoRogue.MapViews;
using GoRogue.Random;
using System.Collections.Generic;
using System.Linq;
using Troschuetz.Random;

namespace GoRogue.MapGeneration.Generators
{
	/// <summary>
	/// Carves out non-overlapping rooms in a map using a basic process of generating a room, and trying to place that room without intersecting another.
	/// Generated rooms will not overlap with each other or existing open areas on the given map.  Generated rooms will not be connected -- for automatic
	/// connection of rooms generated by this algorithm, see GoRogue.MapGeneration.QuickGenerator.GenerateRandomRoomsMap().
	/// </summary>
	public static class BasicRoomsGenerator
	{
		/// <summary>
		/// Generates rooms and adds them to the given map. After this function has been completed, room floor tiles will have a
		/// value of true in the ISettableMapView given.  The value at wall locations will not be modified from the state in which they were passed in.
		/// </summary>
		/// <remarks>
		/// It is guaranteed that the "set" function of the ISettableMapView passed in will only be
		/// called once per tile at maximum.
		/// </remarks>
		/// <param name="map">The map to set values to.</param>
		/// <param name="maxRooms">The maximum number of rooms to attempt to place on the map.</param>
		/// <param name="roomMinSize">The minimum size in width and height of each room.</param>
		/// <param name="roomMaxSize">The maximum size in width and height of each room.</param>
		/// <param name="attemptsPerRoom">
		/// The maximum number of times the position of a room will be generated to try to position
		/// it properly (eg. without overlapping with other rooms), before simply discarding the room.
		/// </param>
		static public IEnumerable<Rectangle> Generate(ISettableMapView<bool> map, int maxRooms, int roomMinSize, int roomMaxSize, int attemptsPerRoom)
			=> Generate(map, null, maxRooms, roomMinSize, roomMaxSize, attemptsPerRoom);

		/// <summary>
		/// Generates rooms and adds them to the given map. After this function has been completed, room floor tiles will have a
		/// value of true in the ISettableMapView given.  The value at wall locations will not be modified from the state in which they were passed in.
		/// </summary>
		/// <remarks>
		/// It is guaranteed that the "set" function of the ISettableMapView passed in will only be
		/// called once per tile at maximum.
		/// </remarks>
		/// <param name="map">The map to set values to.</param>
		/// <param name="rng">The RNG to use to place rooms and determine room size. If null is specified, the default RNG is used.</param>
		/// <param name="maxRooms">The maximum number of rooms to attempt to place on the map.</param>
		/// <param name="roomMinSize">The minimum size in width and height of each room.</param>
		/// <param name="roomMaxSize">The maximum size in width and height of each room.</param>
		/// <param name="attemptsPerRoom">
		/// The maximum number of times the position of a room will be generated to try to position
		/// it properly (eg. without overlapping with other rooms), before simply discarding the room.
		/// </param>
		static public IEnumerable<Rectangle> Generate(ISettableMapView<bool> map, IGenerator rng, int maxRooms, int roomMinSize, int roomMaxSize, int attemptsPerRoom)
		{
			if (maxRooms <= 0)
				throw new System.ArgumentOutOfRangeException(nameof(maxRooms), "maxRooms must be greater than 0.");

			if (roomMinSize <= 0)
				throw new System.ArgumentOutOfRangeException(nameof(roomMinSize), "roomMinSize must be greater than 0.");

			if (roomMaxSize < roomMinSize)
				throw new System.ArgumentOutOfRangeException(nameof(roomMaxSize), "roomMaxSize must be greater than or equal to roomMinSize.");

			if (attemptsPerRoom <= 0)
				throw new System.ArgumentOutOfRangeException(nameof(attemptsPerRoom), "attemptsPerRoom must be greater than 0.");

			if (map.Width - roomMaxSize < 0)
				throw new System.ArgumentOutOfRangeException(nameof(roomMaxSize), "roomMaxSize must be smaller than map.");

			if (rng == null) rng = SingletonRandom.DefaultRNG;

			// To account for walls, dimensions specified were inner dimensions
			roomMinSize += 2;
			roomMaxSize += 2;

			var rooms = new List<Rectangle>();
			for (int r = 0; r < maxRooms; r++)
			{
				int roomWidth = rng.Next(roomMinSize, roomMaxSize + 1);
				int roomHeight = rng.Next(roomMinSize, roomMaxSize + 1);

				int roomXPos = rng.Next(map.Width - roomWidth + 1);
				int roomYPos = rng.Next(map.Height - roomHeight + 1);

				var newRoom = new Rectangle(roomXPos, roomYPos, roomWidth, roomHeight);
				bool newRoomIntersects = checkOverlap(newRoom, rooms, map);

				int positionAttempts = 1;
				while (newRoomIntersects && positionAttempts < attemptsPerRoom)
				{
					roomXPos = rng.Next(map.Width - roomWidth + 1);
					roomYPos = rng.Next(map.Height - roomHeight + 1);

					newRoom = new Rectangle(roomXPos, roomYPos, roomWidth, roomHeight);
					newRoomIntersects = checkOverlap(newRoom, rooms, map);

					positionAttempts++;
				}

				if (!newRoomIntersects)
					rooms.Add(newRoom);
			}

			foreach (var room in rooms)
				createRoom(map, room);

			return rooms;
		}

		static private bool checkOverlap(Rectangle room, List<Rectangle> existingRooms, IMapView<bool> map)
		{
			bool intersected = false;
			foreach (var point in room.Positions())
			{
				if (map[point])
				{
					intersected = true;
					break;
				}
			}


			return intersected || existingRooms.Any(rect => rect.Intersects(room));
		}

		static private void createRoom(ISettableMapView<bool> map, Rectangle room)
		{
			for (int x = room.X + 1; x < room.MaxExtentX; x++)
				for (int y = room.Y + 1; y < room.MaxExtentY; y++)
					map[x, y] = true;
		}
	}
}
