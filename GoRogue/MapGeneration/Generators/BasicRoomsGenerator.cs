using GoRogue.MapViews;
using GoRogue.Random;
using System.Collections.Generic;
using System.Linq;
using Troschuetz.Random;
using SadRogue.Primitives;

namespace GoRogue.MapGeneration.Generators
{
	/// <summary>
	/// Carves out non-overlapping rooms in a map using a basic process of generating a room, and
	/// trying to place that room without intersecting another. Generated rooms will not overlap with
	/// each other or existing open areas on the given map. Generated rooms will not be connected --
	/// for automatic connection of rooms generated by this algorithm, see
	/// <see cref="QuickGenerators.GenerateRandomRoomsMap(ISettableMapView{bool}, int, int, int, int)"/>
	/// and overloads.
	/// </summary>
	public static class BasicRoomsGenerator
	{
		/// <summary>
		/// Generates rooms and adds them to the given map. After this function has been completed,
		/// room floor tiles will have a value of true in the <paramref name="map"/> given. The value at
		/// wall locations will not be modified from the state in which they were passed in.
		/// </summary>
		/// <remarks>
		/// It is guaranteed that the "set" function of the <paramref name="map"/> passed in will only be
		/// called once per tile at maximum.
		/// </remarks>
		/// <param name="map">The map to set values to.</param>
		/// <param name="maxRooms">The maximum number of rooms to attempt to place on the map.</param>
		/// <param name="roomMinSize">The minimum size in width and height of each room.</param>
		/// <param name="roomMaxSize">The maximum size in width and height of each room.</param>
		/// <param name="attemptsPerRoom">
		/// The maximum number of times the position of a room will be generated to try to position
		/// it properly (eg. without overlapping with other rooms), before simply discarding the room.
		/// </param>
		/// <returns>A collection of rectangles representing the interior of each generated room.</returns>
		public static IEnumerable<Rectangle> Generate(ISettableMapView<bool> map, int maxRooms, int roomMinSize, int roomMaxSize, int attemptsPerRoom)
			=> Generate(map, null, maxRooms, roomMinSize, roomMaxSize, attemptsPerRoom);

		/// <summary>
		/// Generates rooms and adds them to the given map. After this function has been completed,
		/// room floor tiles will have a value of true in the <paramref name="map"/> given. The value at
		/// wall locations will not be modified from the state in which they were passed in.
		/// </summary>
		/// <remarks>
		/// It is guaranteed that the "set" function of the <paramref name="map"/> passed in will only be
		/// called once per tile at maximum.
		/// </remarks>
		/// <param name="map">The map to set values to.</param>
		/// <param name="rng">
		/// The RNG to use to place rooms and determine room size. If null is specified, the default
		/// RNG is used.
		/// </param>
		/// <param name="maxRooms">The maximum number of rooms to attempt to place on the map.</param>
		/// <param name="roomMinSize">The minimum size in width and height of each room.</param>
		/// <param name="roomMaxSize">The maximum size in width and height of each room.</param>
		/// <param name="attemptsPerRoom">
		/// The maximum number of times the position of a room will be generated to try to position
		/// it properly (eg. without overlapping with other rooms), before simply discarding the room.
		/// </param>
		/// <returns>A collection of rectangles representing the interior of each generated room.</returns>
		public static IEnumerable<Rectangle> Generate(ISettableMapView<bool> map, IGenerator? rng, int maxRooms, int roomMinSize, int roomMaxSize, int attemptsPerRoom)
		{
			if (maxRooms <= 0)
				throw new System.ArgumentOutOfRangeException(nameof(maxRooms), "Maximum number of rooms must be greater than 0.");

			if (roomMinSize <= 0)
				throw new System.ArgumentOutOfRangeException(nameof(roomMinSize), "Minimum room size must be greater than 0.");

			if (roomMaxSize < roomMinSize)
				throw new System.ArgumentOutOfRangeException(nameof(roomMaxSize), "Maximum room size must be greater than or equal to roomMinSize.");

			if (attemptsPerRoom <= 0)
				throw new System.ArgumentOutOfRangeException(nameof(attemptsPerRoom), "Placement attempts per room must be greater than 0.");

			if (map.Width - roomMaxSize < 0)
				throw new System.ArgumentOutOfRangeException(nameof(roomMaxSize), "Maximum room size must be smaller than map.");

			if (rng == null) rng = SingletonRandom.DefaultRNG;

			// To account for walls, dimensions specified were inner dimensions
			roomMinSize += 2;
			roomMaxSize += 2;

			var rooms = new List<Rectangle>();
			for (int r = 0; r < maxRooms; r++)
			{
				int roomWidth = rng.Next(roomMinSize, roomMaxSize + 1);
				int roomHeight = rng.Next(roomMinSize, roomMaxSize + 1);

				int roomXPos = rng.Next(map.Width - roomWidth + 1);
				int roomYPos = rng.Next(map.Height - roomHeight + 1);

				var newRoom = new Rectangle(roomXPos, roomYPos, roomWidth, roomHeight);
				bool newRoomIntersects = checkOverlap(newRoom, rooms, map);

				int positionAttempts = 1;
				while (newRoomIntersects && positionAttempts < attemptsPerRoom)
				{
					roomXPos = rng.Next(map.Width - roomWidth + 1);
					roomYPos = rng.Next(map.Height - roomHeight + 1);

					newRoom = new Rectangle(roomXPos, roomYPos, roomWidth, roomHeight);
					newRoomIntersects = checkOverlap(newRoom, rooms, map);

					positionAttempts++;
				}

				// Our rectangles represent the rooms with walls at this point, so we shrink them to match convention of interior
				// only
				if (!newRoomIntersects)
					rooms.Add(newRoom.Expand(-1, -1));  
			}

			foreach (var room in rooms)
				createRoom(map, room);

			return rooms;
		}

		private static bool checkOverlap(Rectangle room, List<Rectangle> existingRooms, IMapView<bool> map)
		{
			bool intersected = false;
			foreach (var point in room.Positions())
			{
				if (map[point])
				{
					intersected = true;
					break;
				}
			}

			return intersected || existingRooms.Any(rect => rect.Intersects(room));
		}

		private static void createRoom(ISettableMapView<bool> map, Rectangle room)
		{
			foreach (var pos in room.Positions())
				map[pos] = true;
		}
	}
}
