using System;
using System.Diagnostics.CodeAnalysis;
using System.Runtime.CompilerServices;
using System.Runtime.Serialization;
using JetBrains.Annotations;
using SadRogue.Primitives;

namespace GoRogue.MapGeneration.ContextComponents
{
    /// <summary>
    /// An item added to a generation context component and the name of the step that added it.
    /// </summary>
    /// <typeparam name="TItem">The type of item stored in the pairing.</typeparam>
    [DataContract]
    [PublicAPI]
    public readonly struct ItemStepPair<TItem> : IEquatable<ItemStepPair<TItem>>, IMatchable<ItemStepPair<TItem>>
        where TItem : notnull
    {
        /// <summary>
        /// The item.
        /// </summary>
        [DataMember] public readonly TItem Item;

        /// <summary>
        /// The name associated with the step that created the item.
        /// </summary>
        [DataMember] public readonly string Step;

        /// <summary>
        /// Constructor.
        /// </summary>
        /// <param name="item"/>
        /// <param name="step"/>
        public ItemStepPair(TItem item, string step)
        {
            Item = item;
            Step = step;
        }

        /// <summary>
        /// Returns a string representing the item and the name of the step that added it.
        /// </summary>
        /// <returns/>
        [Pure]
        public override string ToString() => $"{Item}: {Step}";

        #region Tuple Compatibility

        /// <summary>
        /// Supports C# Deconstruction syntax.
        /// </summary>
        /// <param name="item"/>
        /// <param name="step"/>
        public void Deconstruct(out TItem item, out string step)
        {
            item = Item;
            step = Step;
        }

        /// <summary>
        /// Implicitly converts a ItemStepPair to an equivalent tuple.
        /// </summary>
        /// <param name="pair"/>
        /// <returns/>
        public static implicit operator (TItem item, string step)(ItemStepPair<TItem> pair) => pair.ToTuple();

        /// <summary>
        /// Implicitly converts a tuple to its equivalent ItemStepPair.
        /// </summary>
        /// <param name="tuple"/>
        /// <returns/>
        public static implicit operator ItemStepPair<TItem>((TItem item, string step) tuple) => FromTuple(tuple);

        /// <summary>
        /// Converts the pair to an equivalent tuple.
        /// </summary>
        /// <returns/>
        [Pure]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public (TItem item, string step) ToTuple() => (Item, Step);

        /// <summary>
        /// Converts the tuple to an equivalent ItemStepPair.
        /// </summary>
        /// <param name="tuple"/>
        /// <returns/>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        [SuppressMessage("ReSharper", "CA1000")] // Must be static to comply with implicit operator rules
        public static ItemStepPair<TItem> FromTuple((TItem item, string step) tuple)
            => new ItemStepPair<TItem>(tuple.item, tuple.step);

        #endregion

        #region EqualityComparison

        /// <summary>
        /// True if the given pair has equivalent items and that were generated by the same step; false otherwise.
        /// </summary>
        /// <param name="other"/>
        /// <returns/>
        [Pure]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Equals(ItemStepPair<TItem> other) => Item.Equals(other.Item) && Step == other.Step;

        /// <summary>
        /// True if the given pair has equivalent items and that were generated by the same step; false otherwise.
        /// </summary>
        /// <param name="other"/>
        /// <returns/>
        [Pure]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Matches(ItemStepPair<TItem> other) => Equals(other);

        /// <summary>
        /// True if the given object is an ItemStepPair that has an equivalent item that was generated by the same step;
        /// false otherwise.
        /// </summary>
        /// <param name="obj"/>
        /// <returns/>
        [Pure]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public override bool Equals(object? obj) => obj is ItemStepPair<TItem> pair && Equals(pair);

        /// <summary>
        /// Returns a hash code based on all of the pair's fields.
        /// </summary>
        /// <returns/>
        [Pure]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public override int GetHashCode() => Item.GetHashCode() ^ Step.GetHashCode();

        /// <summary>
        /// True if the given pairs have the same component and tag; false otherwise.
        /// </summary>
        /// <param name="left"/>
        /// <param name="right"/>
        /// <returns/>
        public static bool operator ==(ItemStepPair<TItem> left, ItemStepPair<TItem> right) => left.Equals(right);

        /// <summary>
        /// True if the given pairs have different components and/or tags; false otherwise.
        /// </summary>
        /// <param name="left"/>
        /// <param name="right"/>
        /// <returns/>
        public static bool operator !=(ItemStepPair<TItem> left, ItemStepPair<TItem> right) => !(left == right);

        #endregion
    }
}
