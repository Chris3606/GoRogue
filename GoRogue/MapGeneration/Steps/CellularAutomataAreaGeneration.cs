using System.Collections.Generic;
using GoRogue.MapGeneration.ContextComponents;
using GoRogue.MapViews;
using GoRogue.Random;
using JetBrains.Annotations;
using SadRogue.Primitives;
using Troschuetz.Random;

namespace GoRogue.MapGeneration.Steps
{
    /// <summary>
    /// Uses a cellular automata generation and smoothing algorithm to generate cave-like areas in a map.
    /// </summary>
    [PublicAPI]
    public class CellularAutomataAreaGeneration : GenerationStep
    {
        /// <summary>
        /// Optional tag that must be associated with the component used to store areas generated by this algorithm.
        /// </summary>
        public readonly string? AreasComponentTag;

        /// <summary>
        /// Optional tag that must be associated with the component used to set wall/floor status of tiles changed by this
        /// algorithm.
        /// </summary>
        public readonly string? WallFloorComponentTag;

        /// <summary>
        /// The RNG to use for initially filling the map.
        /// </summary>
        public IGenerator RNG = GlobalRandom.DefaultRNG;

        /// <summary>
        /// The adjacency rule to use to determine the unique areas generated by this algorithm.
        /// </summary>
        public AdjacencyRule AreaAdjacencyRule = AdjacencyRule.Cardinals;

        /// <summary>
        /// Represents the percent chance that a given cell will be a floor cell when the map is
        /// initially randomly filled. Recommended to be in range [40, 60].
        /// </summary>
        public ushort FillProbability = 40;

        /// <summary>
        /// Total number of times the cellular automata-based smoothing algorithm is executed.
        /// Recommended to be in range [2, 10].
        /// </summary>
        public int TotalIterations = 7;

        /// <summary>
        /// Total number of times the cellular automata smoothing variation that is more likely to
        /// result in "breaking up" large areas will be run before switching to the more standard
        /// nearest neighbors version. Must be less than or equal to <see cref="TotalIterations"/>.
        /// Recommended to be in range [2, 7].
        /// </summary>
        public int CutoffBigAreaFill = 4;

        /// <summary>
        /// Creates a new cellular automata based area generation step.
        /// </summary>
        /// <param name="name">The name of the generation step.  Defaults to <see cref="CellularAutomataAreaGeneration" />.</param>
        /// ///
        /// <param name="areasComponentTag">
        /// Optional tag that must be associated with the component used to store areas
        /// created by the algorithm.  Defaults to "Areas".
        /// </param>
        /// <param name="wallFloorComponentTag">
        /// Optional tag that must be associated with the map view component used to store/set
        /// floor/wall status.  Defaults to "WallFloor".
        /// </param>
        public CellularAutomataAreaGeneration(string? name = null, string? areasComponentTag = "Areas",
                                              string? wallFloorComponentTag = "WallFloor")
            : base(name)
        {
            AreasComponentTag = areasComponentTag;
            WallFloorComponentTag = wallFloorComponentTag;
        }

        /// <inheritdoc />
        protected override IEnumerator<object?> OnPerform(GenerationContext context)
        {
            // Validate configuration
            if (CutoffBigAreaFill > TotalIterations)
                throw new InvalidConfigurationException(this, nameof(CutoffBigAreaFill),
                    $"The value must be less than or equal to the value of {nameof(TotalIterations)}.");

            if (FillProbability > 100)
                throw new InvalidConfigurationException(this, nameof(FillProbability),
                    "The value must be a valid percent (between 0 and 100).");

            // Get or create/add a wall-floor context component
            var wallFloorContext = context.GetFirstOrNew<ISettableGridView<bool>>(
                () => new ArrayView<bool>(context.Width, context.Height),
                WallFloorComponentTag);

            // Get or create/add an areas context component
            var areasContext = context.GetFirstOrNew(
                () => new ItemList<Area>(),
                AreasComponentTag);

            // Create a new map view to use as a temporary value during generation, so that existing map generation
            // features aren't erased by these (since we set the map to random values to start the process)
            var tempMap = new ArrayView<bool>(context.Width, context.Height);

            // Set the non-edge points to random values based on fill probability.  The edges are untouched so are
            // always walls
            foreach (var pos in tempMap.Bounds().Expand(-1, -1).Positions())
                tempMap[pos] = RNG.PercentageCheck(FillProbability);
            yield return null;

            // Create a new array map to use in the smoothing algorithms to temporarily store old values.
            // Allocating it here instead of in the smoothing minimizes allocations.
            var oldMap = new ArrayView<bool>(tempMap.Width, tempMap.Height);

            // Iterate over the generated values, smoothing them with the appropriate algorithm
            for (int i = 0; i < TotalIterations; i++)
            {
                CellAutoSmoothingAlgo(tempMap, oldMap, i < CutoffBigAreaFill);
                yield return null;
            }

            // Fill to a rectangle to ensure the resulting areas are enclosed
            foreach (var pos in tempMap.Bounds().PerimeterPositions())
                tempMap[pos] = false;

            // Find all the areas generated by the algorithm and add them to the area list
            areasContext.AddRange(MapAreaFinder.MapAreasFor(tempMap, AreaAdjacencyRule), Name);

            // Set all new floor spaces to true in the wall-floor map.  It does _not_ set walls to false,
            // as false is the default for a new map view and if it was existing we want to preserve the
            // existing floors
            foreach (var pos in tempMap.Positions())
                if (tempMap[pos])
                    wallFloorContext[pos] = true;
        }

        private static void CellAutoSmoothingAlgo(ArrayView<bool> map, ArrayView<bool> oldMap, bool bigAreaFill)
        {
            // Record current state of the map so we can compare to it to determine nearest walls
            oldMap.ApplyOverlay(map);

            // Iterate over inner square only to avoid messing with outer walls
            foreach (var pos in map.Bounds().Expand(-1, -1).Positions())
            {
                if (CountWallsNear(oldMap, pos, 1) >= 5 || bigAreaFill && CountWallsNear(oldMap, pos, 2) <= 2)
                    map[pos] = false;
                else
                    map[pos] = true;
            }
        }

        private static int CountWallsNear(ArrayView<bool> map, Point centerPos, int distance)
        {
            int count = 0;

            foreach (var pos in Radius.Square.PositionsInRadius(centerPos, distance))
                if (pos != centerPos &&  map[pos])
                    count += 1;

            return count;
        }
    }
}
